<!--
   Except as noted,
   Copyright 2011 Kevin Reid, under the terms of the MIT License as detailed in
   the accompanying file README.md or <http://opensource.org/licenses/MIT>.
  
   Exception: The overall structure of WebGL initialization and context
   management is copied from Learning WebGL, Lesson 16, at
   http://learningwebgl.com/blog/?p=1786 (as of September 2011). No license is
   stated on that site, but I (Kevin Reid) believe that it is obviously the
   authors' intent to make this code free to use.
-->
<!doctype html>
<html><head>
<title>Cube Game</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="viewport" content="width=device-width">
<link rel="stylesheet" href="style.css" type="text/css">

<script type="text/javascript" src="webgl-debug.js"></script>
<script type="text/javascript" src="webgl-utils.js"></script>
<script type="text/javascript" src="glMatrix.js"></script>
<script type="text/javascript" src="util.js"></script>
<script type="text/javascript" src="blockset.js"></script>
<script type="text/javascript" src="world.js"></script>
<script type="text/javascript" src="world-gen.js"></script>
<script type="text/javascript" src="circuit.js"></script>
<script type="text/javascript" src="world-render.js"></script>
<script type="text/javascript" src="block-render.js"></script>
<script type="text/javascript" src="player.js"></script>
<script type="text/javascript" src="input.js"></script>

<script id="shader-fs" type="x-shader/x-fragment">
    #ifdef GL_ES
    precision highp float;
    #endif
    
    varying vec4 vColor;
    varying vec3 vGridPosition;
    varying vec3 vFixedOrientationPosition;
    varying vec2 vTextureCoord;
    varying float vFog;
    varying vec3 vNormal;
    varying float vDistanceFromEye;

    uniform mat4 uPMatrix;
    uniform mat4 uMVMatrix;
    uniform bool uTextureEnabled;
    uniform sampler2D uSampler;
    uniform bool uLighting;
    uniform bool uBumpMapping;
    uniform bool uStipple;
    
    const vec4 cSky = vec4(0.1,0.3,0.5,1.0);   
    const vec4 cHorizon = vec4(0.7,0.8,1.0,1.0);  
    const vec4 cGround = vec4(0.5,0.4,0.4,1.0);
    const float cModEpsilon = 1e-20;
    const float cTileCurvature = 0.2;
    const float cTileBumpDistance = 7.0;

    const float cLightAmbient = 0.5;
    const vec3 cLight1Dir = vec3(0.8,-0.2,0);
    const vec3 cLight2Dir = vec3(-0.8,0.7,0.5);

    // What is the illumination from the given (unit vector) direction?
    float lightEnv(vec3 dir) {
      return max(0.0, dot(cLight1Dir, dir)) + max(0.0, dot(cLight2Dir, dir));
    }
    
    // Componentwise x^7. pow() is unsuitable for negative arguments.
    vec3 pow7vec3(vec3 x) {
      vec3 y = x*x*x;
      return y*y*x;
    }

    // Add amount of any component over 1.0 to all components (makes overbright colors turn to white)
    vec3 spill(vec3 v) {
      return v + vec3(max(1.0, max(v.r, max(v.g, v.b))) - 1.0);
    }

    float lighting() {
      // 'cell' is a vector with components in [-1.0, 1.0] indicating this point's
      // offset from the center of its sub-cube
      vec3 normal;
      if (uBumpMapping) {
        vec3 cell = (mod(vGridPosition * float(TILE_SIZE) + cModEpsilon, 1.0) - vec3(0.5)) * 2.0;
        normal = normalize(vNormal + cTileCurvature / max(1.0, vDistanceFromEye / cTileBumpDistance) * pow7vec3(cell));
      } else {
        normal = vNormal;
      }
      return cLightAmbient + lightEnv(normal);
    }
    
    void main(void) {
        if (uStipple && mod(gl_FragCoord.x - gl_FragCoord.y, 2.0) < 1.0)
          discard;
        
        // color/lighting calculation
        // if the vertex normal is zero, then that means "do not use lighting"
        vec4 color = vec4(vec3(vColor) * 
            (!uLighting || vNormal == vec3(0,0,0)
              ? 1.0 
              : lighting()), vColor.a);

        if (uTextureEnabled) {
          color *= texture2D(uSampler, vTextureCoord);

          // alpha test
          if (color.a <= 0.0)
            discard;
        }
        
        color = vec4(spill(vec3(color)), color.a);

        float elevationSine = vFixedOrientationPosition.y / length(vFixedOrientationPosition);
        vec4 fogColor = elevationSine < 0.0
          ? mix(cHorizon, cGround, clamp(log(1.0 + -elevationSine * 120.0), 0.0, 1.0))
          : mix(cHorizon, cSky, clamp(log(1.0 + elevationSine * 2.0), 0.0, 1.0));
        gl_FragColor = color * (1.0-vFog) + fogColor * vFog;
    }
</script>

<script id="shader-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec4 aVertexColor;
    attribute vec3 aVertexNormal;
    attribute vec2 aTextureCoord;

    uniform bool uTextureEnabled;
    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;
    uniform vec3 uViewPosition;
    uniform vec2 uPixelsPerClipUnit;
    uniform float uFogDistance;
    
    uniform bool uParticleMode;     // flag we're rendering point particles
    uniform float uParticleInterp;  // particle system evolution time, [0.0, 1.0]
    uniform bool uParticleExplode; // particles explode or appear/fade?
    
    varying vec4 vColor;
    varying vec3 vGridPosition;
    varying vec3 vFixedOrientationPosition;
    varying vec2 vTextureCoord;
    varying vec3 vNormal;
    varying float vFog;
    varying float vDistanceFromEye;
    
    void main(void) {
        vec3 vertexPosition;
        float pointScale;
        
        if (uParticleMode) {
          // center of block
          vec3 blockPart = floor(aVertexPosition) + 0.5;
          // offset from center of block
          vec3 particlePart = mod(aVertexPosition, 1.0) - 0.5;
          
          // pseudorandom vector constant for the point
          vec3 scramble = normalize(vec3(
            sin(dot(aVertexPosition, vec3(24121.9, 2398.1, 234.8))),
            sin(dot(aVertexPosition, vec3(1024.0, 28.0, 1834.0))),
            sin(dot(aVertexPosition, vec3(486.0, 282.4, 7.215)))
          ));
          
          vertexPosition = uParticleExplode
            ? aVertexPosition + (1.0 * scramble + 0.5 * particlePart) * pow(uParticleInterp, 3.0)
            : aVertexPosition + particlePart * (0.1 + uParticleInterp * 0.1);
          pointScale = 1.0 - pow(uParticleInterp * 1.0, 2.0);
        } else {
          vertexPosition = aVertexPosition;
        }
        
        vGridPosition = vertexPosition;
        vFixedOrientationPosition = vertexPosition - uViewPosition;
        vec4 relativePosition = uMVMatrix * vec4(vertexPosition, 1.0);
        gl_Position = uPMatrix * relativePosition;
        
        if (uParticleMode) {
          // Compute particle size
          vec4 testPosition = relativePosition;
          testPosition.x = uPixelsPerClipUnit.x / float(TILE_SIZE) * 1.2/*appearance fudge factor*/;
          testPosition.y = 0.0;
          testPosition = uPMatrix * testPosition;
          gl_PointSize = testPosition.x / testPosition.w * pointScale;
        }
        
        vTextureCoord = aTextureCoord;
        
        // linear distance from eye, scaled to 1.0 = 100% fog
        vDistanceFromEye = length(vec3(relativePosition));
        
        // fog color mixing parameter
        vFog = clamp(pow(vDistanceFromEye/uFogDistance, 4.0), 0.0, 1.0);
        
        vColor = uTextureEnabled ? vec4(1.0) : aVertexColor;
        vNormal = aVertexNormal;
    }
</script>


<script type="text/javascript">
    "use strict";
    
    var DEBUG = false;
    var TIMESTEP = 1/60;
    var MAX_CATCHUP_MS = 500;
    
    var TIMESTEP_MS = TIMESTEP*1000;
    
    // Settable using the options sidebar
    var config = {};
    function defineOption(name, type, value) {
      config[name] = new PersistentCell("cubes.option." + name, type, value);
    }
    function resetAllOptions() {
      Object.keys(config).forEach(function (k) { config[k].setToDefault(); });
    }
    defineOption("fov", "number", 60);
    defineOption("renderDistance", "number", 100);
    defineOption("lighting", "boolean", true);
    defineOption("bumpMapping", "boolean", true);
    defineOption("debugTextureAllocation", "boolean", false);
    defineOption("debugForceRender", "boolean", false);

    defineOption("generate_wx", "number", 400);
    defineOption("generate_wy", "number", 128);
    defineOption("generate_wz", "number", 400);

    // GL objects
    var gl;
    var theCanvas;
    
    var sceneInfo;
    var cursorInfoElem;
    var cursorInfo;
    
    // Game state, etc. objects
    var player;
    var worldH;
    var input;
    
    var readyToDraw = false;
    
    // prepareProgram fills in these with the locations of the shader program variables
    var attribs = {};
    var uniforms = {};

    // Projection trans

    // View and projection transformation globals.
    var pMatrix = mat4.create();
    var mvMatrix = mat4.create();
    var viewPosition = vec3.create();
    var viewFrustum; // computed

    function calculateFrustum() {
      var matrix = mat4.multiply(pMatrix, mvMatrix, mat4.create());
      mat4.inverse(matrix);
      // matrix is now a clip-space-to-model-space conversion
      
      function dehomog(v4) {
        return [v4[0]/v4[3], v4[1]/v4[3], v4[2]/v4[3]];
      }
      // Return a function which tests whether the point is in the half-space bounded by the plane containing origin, pt1, and pt2, and pointed toward by pt1 cross pt2.
      function makeHalfSpaceTest(origin, pt1, pt2) {
        var normal = vec3.cross(
          vec3.subtract(pt1, origin, vec3.create()),
          vec3.subtract(pt2, origin, vec3.create()),
          vec3.create());
        var vecbuf = vec3.create();
        return function (point) {
          vec3.subtract(point, origin, vecbuf);
          return vec3.dot(vecbuf, normal) > 0;
        }
      }
      var lbn = dehomog(mat4.multiplyVec4(matrix, [-1,-1,-1,1]));
      var lbf = dehomog(mat4.multiplyVec4(matrix, [-1,-1, 1,1]));
      var ltn = dehomog(mat4.multiplyVec4(matrix, [-1, 1,-1,1]));
      var ltf = dehomog(mat4.multiplyVec4(matrix, [-1, 1, 1,1]));
      var rbn = dehomog(mat4.multiplyVec4(matrix, [ 1,-1,-1,1]));
      var rbf = dehomog(mat4.multiplyVec4(matrix, [ 1,-1, 1,1]));
      var rtn = dehomog(mat4.multiplyVec4(matrix, [ 1, 1,-1,1]));
      var rtf = dehomog(mat4.multiplyVec4(matrix, [ 1, 1, 1,1]));
      
      viewFrustum = [
        makeHalfSpaceTest(lbn, lbf, ltf), // left
        makeHalfSpaceTest(rtn, rtf, rbf), // right
        makeHalfSpaceTest(ltn, ltf, rtf), // top
        makeHalfSpaceTest(rbn, rbf, lbf), // bottom
        makeHalfSpaceTest(lbn, ltn, rtn), // near
        makeHalfSpaceTest(lbf, rbf, ltf), // far
      ];
    }

    function aabbInView(aabb) {
      for (var i = 0; i < viewFrustum.length; i++) {
        var outside = true;
        for (var xb = 0; xb < 2; xb++)
        for (var yb = 0; yb < 2; yb++)
        for (var zb = 0; zb < 2; zb++) {
          var vec = [aabb[0][xb], aabb[1][yb], aabb[2][zb]];
          if (viewFrustum[i](vec))
            outside = false;
        }
        if (outside)
          return false;
      }
      return true;
    }
    
    function sendViewUniforms() {
        gl.uniformMatrix4fv(uniforms.uMVMatrix, false, mvMatrix);
        gl.uniform3fv(uniforms.uViewPosition, viewPosition);
        calculateFrustum();
    }

    function updateViewport() {
      var pagePixelWidth = parseInt(window.getComputedStyle(theCanvas,null).width);
      var pagePixelHeight = parseInt(window.getComputedStyle(theCanvas,null).height);
      
      // Specify canvas resolution
      theCanvas.width = pagePixelWidth;
      theCanvas.height = pagePixelHeight;
      
      // WebGL is not guaranteed to give us that resolution; instead, what it
      // can supply is returned in .drawingBuffer{Width,Height}. However, those
      // properties are not supported by, at least, Firefox 6.0.2.
      if (!("drawingBufferWidth" in gl)) {
        gl.drawingBufferWidth = pagePixelWidth;
        gl.drawingBufferHeight = pagePixelHeight;
      }
      
      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
      gl.uniform2f(uniforms.uPixelsPerClipUnit, gl.drawingBufferWidth / 2,
                                                gl.drawingBufferHeight / 2);

      updateProjection();
    }
    
    function updateProjection() {
      var fov = config.fov.get();
      var aspectRatio = gl.drawingBufferWidth / gl.drawingBufferHeight;
      
      var nearestApproachToPlayer = Math.min(
        -Player.aabb[0][0], Player.aabb[0][1],
        -Player.aabb[1][0], Player.aabb[1][1],
        -Player.aabb[2][0], Player.aabb[2][1]);
      var nearPlane = nearestApproachToPlayer 
                      / Math.sqrt(1 + Math.pow(Math.tan(fov/180*Math.PI/2), 2)
                                      * (Math.pow(aspectRatio, 2) + 1));
      
      mat4.perspective(fov,
                       aspectRatio,
                       nearPlane,
                       config.renderDistance.get(),
                       pMatrix);
      
      gl.uniformMatrix4fv(uniforms.uPMatrix, false, pMatrix);
      // uFogDistance is handled by drawScene because it is changed.
    }
    
    // Returns a pair of points along the line of aim of the screen cursor.
    function getAimRay() {
      var pos = input.getMousePos();
      var glxy = [pos[0] / theCanvas.width * 2 - 1, -(pos[1] / theCanvas.height * 2 - 1)];
      
      var unproject = mat4.identity(mat4.create());
      player.render.applyViewRot(unproject);
      player.render.applyViewTranslation(unproject);
      mat4.multiply(pMatrix, unproject, unproject);
      mat4.inverse(unproject);

      var pt1 = fixedmultiplyVec3(unproject, vec3.create([glxy[0], glxy[1], 0]));
      var pt2 = fixedmultiplyVec3(unproject, vec3.create([glxy[0], glxy[1], 1]));

      return [pt1, pt2];
    }

    function raycastFromScreen(radius, callback) {
      var pts = getAimRay();
      return player.getWorld().raycast(pts[0], pts[1], radius, callback);
    }
    
    function BufferAndArray(numComponents) {
      this.numComponents = numComponents;
      this.buffer = gl.createBuffer();
      this.array = null;
    }
    BufferAndArray.prototype.countVertices = function () {
      return this.array.length / this.numComponents;
    };
    BufferAndArray.prototype.load = function (jsArray, checkAgainst) {
      this.array = new Float32Array(jsArray);
      if (checkAgainst && this.countVertices() !== checkAgainst.countVertices()) {
        throw new Error("Inconsistent number of vertices.");
      }
    };
    BufferAndArray.prototype.send = function (mode) {
      gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
      gl.bufferData(gl.ARRAY_BUFFER, this.array, mode);
    };
    BufferAndArray.prototype.attrib = function (attrib) {
      gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
      gl.vertexAttribPointer(attrib, this.numComponents, gl.FLOAT, false, 0, 0);
    };
    BufferAndArray.prototype.deleteResources = function () {
      gl.deleteBuffer(this.buffer);
      this.buffer = this.array = null;
    };
    
    // Manages a set of attribute arrays for some geometry to render.
    // The calcFunc is called and given a set of JS arrays to fill, immediately as well as whenever this.recompute() is called.
    // If calcFunc is null, then the client is expected to fill the arrays manually.
    function RenderBundle(primitive, optTexture, calcFunc, options) {
      options = options || {};
      
      var v = new BufferAndArray(3);
      var n = new BufferAndArray(3);
      if (!optTexture) var c = new BufferAndArray(4);
      if (optTexture) var t = new BufferAndArray(2);
      
      if (calcFunc != null) {
        this.recompute = function () {
          var vertices = [];
          var normals = [];
          var colors = optTexture ? null : [];
          var texcoords = optTexture ? [] : null;
          calcFunc(vertices, normals, optTexture ? texcoords : colors);

          v.load(vertices);
          v.send(gl.STATIC_DRAW);
          n.load(normals, v);
          n.send(gl.STATIC_DRAW);

          if (optTexture) {
            t.load(texcoords, v);
            t.send(gl.STATIC_DRAW);
          } else {
            c.load(colors, v);
            c.send(gl.STATIC_DRAW);
          }
        };

        this.recompute();
      }

      // made available for partial updates
      this.vertices = v;
      this.normals = n;
      this.colors = c;
      this.texcoords = t;
      
      function draw() {
        v.attrib(attribs.aVertexPosition);
        n.attrib(attribs.aVertexNormal);
        
        gl.uniform1i(uniforms.uTextureEnabled, optTexture ? 1 : 0);

        if (optTexture) {
          gl.enableVertexAttribArray(attribs.aTextureCoord);
          gl.disableVertexAttribArray(attribs.aVertexColor);
          
          t.attrib(attribs.aTextureCoord);
  
          gl.activeTexture(gl.TEXTURE0);
          gl.bindTexture(gl.TEXTURE_2D, optTexture);
          gl.uniform1i(uniforms.uSampler, 0);
        } else {
          gl.disableVertexAttribArray(attribs.aTextureCoord);
          gl.enableVertexAttribArray(attribs.aVertexColor);

          c.attrib(attribs.aVertexColor);
        }
        var count = v.countVertices();
        totalVertices += count;
        gl.drawArrays(primitive, 0, count);
      };
      this.draw = options.aroundDraw ? function () { options.aroundDraw(draw); } : draw;
      
      this.deleteResources = function () {
        v.deleteResources();        this.vertices  = v = null;
        n.deleteResources();        this.normals   = n = null;
        if (c) c.deleteResources(); this.colors    = c = null;
        if (t) t.deleteResources(); this.texcoords = t = null;
      }
    }
    
    function BlockParticles(location, blockType, destroyMode, symm) {
      var blockWorld = blockType.world;
      var k = 2;
      var t0 = Date.now();
      var rb = new RenderBundle(gl.POINTS, null, function (vertices, normals, colors) {
        var TILE_SIZE = World.TILE_SIZE;
        for (var x = 0; x < TILE_SIZE; x++) {
          for (var y = 0; y < TILE_SIZE; y++) {
            for (var z = 0; z < TILE_SIZE; z++) {
              if (!destroyMode) {
                if (!(x < k || x >= TILE_SIZE-k || y < k || y >= TILE_SIZE-k || z < k || z >= TILE_SIZE-k))
                  continue;
                var c = 1.0 - Math.random() * 0.04;
                colors.push(c,c,c,1);
              } else if (blockWorld) {
                blockWorld.gt(x,y,z).writeColor(1, colors, colors.length);
                if (colors[colors.length - 1] <= 0.0) {
                  // transparent, skip
                  colors.length -= 4;
                  continue;
                }
              } else if (blockType.color) {
                // destroy mode for color cubes
                blockType.writeColor(1, colors, colors.length);
              }
              var v = applyCubeSymmetry(symm, 1, [
                (x+0.5)/TILE_SIZE,
                (y+0.5)/TILE_SIZE,
                (z+0.5)/TILE_SIZE
              ]);
              
              vertices.push(location[0]+v[0],
                            location[1]+v[1],
                            location[2]+v[2]);
              normals.push(0,0,0); // disable lighting
            }
          }
        }
      }, {
        aroundDraw: function (draw) {
          gl.uniform1i(uniforms.uParticleMode, 1);
          gl.uniform1i(uniforms.uParticleExplode, destroyMode ? 1 : 0);
          gl.uniform1f(uniforms.uParticleInterp, t());
          draw();
          gl.uniform1i(uniforms.uParticleMode, 0);
        }
      });
      
      function t() {
        return Math.min((Date.now() - t0) * 0.003, 1);
      }
      
      rb.expired = function () { return t() >= 1; };
      
      return rb;
    }

    var debugR;
    var skyboxR;
    
    function initBuffers() {
      debugR = new RenderBundle(gl.LINES, null, function (vertices, normals, colors) {
        if (player) player.renderDebug(vertices, normals, colors);
      });
      
      skyboxR = new RenderBundle(gl.TRIANGLES, null, function (vertices, normals, colors) {
        // abstracted in case this is useful elsewhere ...
        function cube(vertices, colors, size, outward) {
          function ppush(a, b, c) {
            var v = [];
            v[dim] = a;
            v[da] = b;
            v[db] = c;
            vertices.push(v[0], v[1], v[2]);
            normals.push(0,0,0); // TODO stub
            colors.push(1, 0, 0, 1);
          }
          for (var dim = 0; dim < 3; dim++) {
            for (var dir = -1; dir < 2; dir+=2) {
              var da = mod(dim + (outward ? 1 : -1) * dir, 3);
              var db = mod(dim + (outward ? 2 : -2) * dir, 3);
              ppush(dir*size, -size, -size);
              ppush(dir*size,  size, -size);
              ppush(dir*size,  size,  size);
              ppush(dir*size,  size,  size);
              ppush(dir*size, -size,  size);
              ppush(dir*size, -size, -size);
            }
          }
        }
        
        // While rendering this, the fog distance is adjusted so that anything
        // farther than 1 unit is fully fogged.
        cube(vertices, colors, 1, false);
      });
    }
    
    var lastGLErrors = [];
    function drawScene(playerRender) {
        var wrend = playerRender.getWorldRenderer();

        // Rendering settings for skybox
        mat4.identity(mvMatrix);
        playerRender.applyViewRot(mvMatrix);
        viewPosition = [0,0,0];
        sendViewUniforms();
        gl.uniform1f(uniforms.uFogDistance, 1); // 0 would be div-by-0
        gl.disable(gl.DEPTH_TEST);
        
        // The skybox exceeeds the fog distance, so it is rendered fully fogged
        // and only the fog-shading determines the sky color. This ensures that
        // normal geometry fades smoothly into the sky rather than turning
        // a possibly-different fog color.
        skyboxR.draw();
        
        // Rendering settings for normal geometry
        gl.enable(gl.DEPTH_TEST);
        gl.clear(gl.DEPTH_BUFFER_BIT); // Backdrop depth is irrelevant
        gl.uniform1f(uniforms.uFogDistance, config.renderDistance.get());

        viewPosition = playerRender.getPosition();
        playerRender.applyViewTranslation(mvMatrix);
        sendViewUniforms();

        wrend.draw();
        debugR.draw();
        player.render.selectionRender.draw();
        
        var e, errs = [];
        while (e = gl.getError()) {
          errs.push(e);
        }
        
        // Selection info
        cursorInfo.data = "";
        var sel = player.getSelection();
        if (sel != null) {
          var sx = Infinity;
          var sy = -Infinity;
          var cube = sel.cube;
          for (var dx = 0; dx <= 1; dx++)
          for (var dy = 0; dy <= 1; dy++)
          for (var dz = 0; dz <= 1; dz++) {
            var vec = [cube[0]+dx,cube[1]+dy,cube[2]+dz,1];
            mat4.multiplyVec4(mvMatrix, vec);
            mat4.multiplyVec4(pMatrix, vec);
            sx = Math.min(sx, vec[0]/vec[3]);
            sy = Math.max(sy, vec[1]/vec[3]);
          }
          if (isFinite(sx) && isFinite(sy)) {
            cursorInfoElem.style.left = (sx + 1) / 2 * theCanvas.width + "px";
            cursorInfoElem.style.bottom = (sy + 1) / 2 * theCanvas.height + "px";
            
            var world = player.getWorld();
            var value = world.g(cube[0],cube[1],cube[2]);
            var sub = world.gSub(cube[0],cube[1],cube[2]);
            var type = world.gt(cube[0],cube[1],cube[2]);
            var text = 
              value
              + (sub ? ":" + sub : "")
              + " at " + sel.cube;

            var circuit = world.getCircuit(cube);
            if (circuit !== null) {
              text += "\nCircuit: " + type.behavior.name + " " + circuit.describeBlock(cube);
            }
            cursorInfo.data = text;
          }
        }
        
        // Per-frame debug/stats info
        var text = "";
        {
          var pp = viewPosition;
          var d = 2;
          text += "XYZ: " + pp[0].toFixed(d) + "," + pp[1].toFixed(d) + "," + pp[2].toFixed(d) + "\n";
        }
        if (errs.length) {
          lastGLErrors = errs;
          text += "GL errors:";
          errs.forEach(function (e) {
            text += " " + WebGLDebugUtils.glEnumToString(e);
          });
          text += "\n";
        } else if (lastGLErrors.length) {
          text += "Previous GL errors:";
          lastGLErrors.forEach(function (e) {
            text += " " + WebGLDebugUtils.glEnumToString(e);
          });
          text += "\n";
        }
        text += totalVertices + " vertices\n";
        text += fpsDesc + "\n";
        text += wrend.debugText();
        sceneInfo.data = text;
        
        totalVertices = 0;
        renderCount++;
    }
    
    var fpsDesc = "", stepCount = 0, renderCount = 0, chunkRenders = 0, totalVertices = 0;
    
    var lastStepTime = null;
    function doOneStep() {
      player.stepYourselfAndWorld();
      input.step();
      stepCount++;
    }
    function doStep() {
      // perform limited catch-up
      var now = Date.now();
      if (lastStepTime === null)
        lastStepTime = now;
      if ((now - lastStepTime) > MAX_CATCHUP_MS)
        lastStepTime = now - MAX_CATCHUP_MS;
      
      while ((now - lastStepTime) > TIMESTEP_MS) {
        doOneStep();
        lastStepTime += TIMESTEP_MS;
      }
    }
    
    var animFrameWasRequested = false;
    function scheduleDraw() {
      if (!animFrameWasRequested && readyToDraw) {
        window.requestAnimFrame(function () {
          animFrameWasRequested = false;

          // done here because chunk updating should be deprioritized at the same time drawing would be
          chunkRenders += player.render.getWorldRenderer().updateSomeChunks();

          drawScene(player.render);

          if (config.debugForceRender.get()) scheduleDraw();
        }, theCanvas);
        animFrameWasRequested = true;
      }
    }
    config.debugForceRender.listen({changed: function () { scheduleDraw(); return true; }});

    // statistics are reset once per second
    setInterval(function () {
      fpsDesc = stepCount + " steps/s, " + renderCount + " frames/s, " + chunkRenders + " chunk rebuilds";
      stepCount = renderCount = chunkRenders = 0;
    }, 1000);
    
    // for making our loading more async
    var ABORT = {};
    function sequence(actions, catcher) {
      var t0 = undefined;
      function sub(i) {
        if (i >= actions.length) {
          return;
        } else {
          setTimeout(function () {
            var a = actions[i];
            if (typeof a == 'string') {
              var t1 = Date.now();
              sceneInfo.data += a + "\n";
              if (typeof console !== 'undefined')
                console.log(t0 ? "(+"+(t1-t0)+" ms)" : "        ", a);
              t0 = t1;
            } else {
              try {
                if (actions[i]() === ABORT) return;
              } catch (e) {
                catcher(e);
              }
            }
            sub(i+1);
          }, 1);
        }
      }
      sub(0);
    }
    
    function webGLStart() {
      sceneInfo = dynamicText(document.getElementById('info'));
      cursorInfoElem = document.getElementById('cursor-info');
      cursorInfo = dynamicText(cursorInfoElem);

      sequence([
        function () {
          if (typeof testSettersWork === 'undefined' || !testSettersWork()) {
            document.getElementById("feature-error-notice").style.removeProperty("display");
            document.getElementById("feature-error-text").appendChild(document.createTextNode("ECMAScript 5 property accessors on frozen objects"));
          }
        },
        "Getting WebGL...",
        function () {
          theCanvas = document.getElementById('view-canvas');

          gl = theCanvas.getContext("experimental-webgl", {
            antialias: false // MORE FILLRATE!!!
          });
          if (DEBUG) {
            gl = WebGLDebugUtils.makeDebugContext(gl);
          } else {
            WebGLDebugUtils.init(gl);
          }

          if (!gl) {
            document.getElementById("webgl-error-notice").style.removeProperty("display");
            return ABORT;
          }
        },
        "Setting up WebGL...",
        function () {
          var decls = {
            TILE_SIZE: World.TILE_SIZE
          };
          prepareProgram(gl,
                         prepareShader(gl, "shader-vs", decls),
                         prepareShader(gl, "shader-fs", decls),
                         attribs, uniforms);          
          
          // Set up viewport and projection matters
          updateViewport();
          window.addEventListener("resize", function () {
            updateViewport();
            return true;
          }, false);
          
          // Bind and send rendering options
          config.lighting.nowAndWhenChanged(function (v) {
            gl.uniform1i(uniforms.uLighting, v ? 1 : 0);
            scheduleDraw();
            return true;
          });
          config.bumpMapping.nowAndWhenChanged(function (v) {
            gl.uniform1i(uniforms.uBumpMapping, v ? 1 : 0);
            scheduleDraw();
            return true;
          });
          var projectionL = {changed: function (v) {
            updateProjection();
            scheduleDraw();
            return true;
          }};
          config.fov.listen(projectionL);
          config.renderDistance.listen(projectionL);

          // Initial GL state
          gl.enableVertexAttribArray(attribs.aVertexPosition);
          gl.enableVertexAttribArray(attribs.aVertexNormal);
          gl.enable(gl.DEPTH_TEST);
          gl.enable(gl.CULL_FACE);
          
          initBuffers();
        },
        "Loading worlds...",
        function () {
          var hasLocalStorage = typeof localStorage !== 'undefined';
          document.getElementById('local-save-controls').style.display = hasLocalStorage ? 'block' : 'none';
          document.getElementById('local-save-warning').style.display = !hasLocalStorage ? 'block' : 'none';
          if (hasLocalStorage) {
            var worldData = localStorage.getItem("world");
            if (worldData !== null) {
              try {
                worldH = cyclicUnserialize(JSON.parse(worldData), World);
              } catch (e) {
                if (typeof console !== 'undefined')
                  console.error(e);
                alert("Failed to load saved world!");
              }
            }
          } else {
            console.warn("localStorage not available; world will not be saved.");
          }
          if (!worldH) {
            worldH = generateWorlds();
          }
        },
        "Painting blocks...", // this is what takes the time in world renderer construction
        function () {
          // done after some GL init because player creates world renderer object internally
          player = new Player(worldH);
        },
        "Finishing...",
        function () {
          input = new Input(theCanvas, player.input, document.getElementById("menu"));
          theCanvas.focus();
          readyToDraw = true;

          setInterval(doStep, TIMESTEP_MS);
        },
        "Ready!"
      ], function (exception) {
        sceneInfo.data += exception;
        document.getElementById("load-error-notice").style.removeProperty("display");
        document.getElementById("load-error-text").appendChild(document.createTextNode("" + exception));
        throw exception; // propagate to browser console
      });
    }

</script>


</head>


<body onload="webGLStart();">
    <div class="overlay-bounds">
      <canvas id="view-canvas" tabindex="0" class="viewport" width="640" height="480">
        <div class="error-notice">
          <p>Sorry, but the web browser you are using does not appear to support WebGL (or even Canvas).</p>
        </div>
      </canvas>
      <pre id="info" class="text-overlay">Not ready...</pre>
      <pre id="cursor-info" class="text-overlay"></pre>
    </div>
    <div id="menu" style="visibility: hidden; left: 1px; top: 1px;">
      <!-- arbitrary initial position -->
    </div>
    <div id="error-notices">
    <div id="load-error-notice" class="error-notice" style="display: none;">
      <p>Sorry, but there was an unexpected error while loading the game.</p>
      <p><pre id="load-error-text" style="white-space: pre-wrap;"></pre></p>
    </div>
    <div id="feature-error-notice" class="error-notice" style="display: none;">
      <p>Sorry, the browser you are using does not support some required features. These problems were detected:</p>
      <p><pre id="feature-error-text" style="white-space: pre-wrap;"></pre></p>
      <p>If you are looking for a compatible browser, I recommend Google Chrome.</p>
    </div>
    <div id="webgl-error-notice" class="error-notice" style="display: none;">
      <p>Sorry, the web browser you are using does not appear to support WebGL.</p>
    </div>
    </div>

    <div id="toggles">
      <button id="optionsbtn" onclick="this.style.display='none'; document.getElementById('options').style.display='block'; document.getElementById('view-canvas').focus();">Options</button>
      <button id="helpbtn" onclick="this.style.display='none'; document.getElementById('help').style.display='block'; document.getElementById('view-canvas').focus();">Help</button>
    </div>

    <div id="options" class="sidebar" onclick="if (event.target.tagName == 'INPUT' || event.target.tagName == 'LABEL' || event.target.tagName == 'BUTTON' || event.target.tagName == 'TEXTAREA') return true; this.style.display='none'; document.getElementById('optionsbtn').style.display='inline'; document.getElementById('view-canvas').focus();" style="display: none;">
      <p>Click to close.</p>

      <h2>Save/Load</h2>
      
      <form onsubmit="return false;" action=""  style="text-align: center">
        <p id="local-save-controls">
          <button onclick="
            localStorage.setItem('world', JSON.stringify(cyclicSerialize(worldH))); return false;
          ">Save</button>
          <button onclick="
            worldH = cyclicUnserialize(JSON.parse(localStorage.getItem('world')), World);
            player.setWorld(worldH);
            return false;
          ">Revert to saved</button>
        </p>
        <p id="local-save-warning" style="display: none">
          Your browser does not appear to support local storage. This world will be lost when you close the page.
        </p>
        <p style="">
          <textarea id="loadfield" width="20" height="3" style="width: 80%;"></textarea>
          <br>
          <button onclick="
            document.getElementById('loadfield').value = JSON.stringify(cyclicSerialize(worldH)); return false;
          ">Text Export</button>
          <button onclick="
            while (document.getElementById('load-error').firstChild)
              document.getElementById('load-error').removeChild(
                document.getElementById('load-error').firstChild);
            try {
              worldH = cyclicUnserialize(JSON.parse(document.getElementById('loadfield').value), World)
              player.setWorld(worldH);
            } catch (e) {
              console.log(e);
              document.getElementById('load-error').appendChild(document.createTextNode(e));
            }
            return false;
          ">Text Import</button>
          <br>
          <div id="load-error" style="text-shadow: 0 0 .3em red;"></div>
        </p>
      </form>
      
      <h2>World</h2>

      <form onsubmit="return false;" action=""  style="text-align: center">
        <table class="optionline">
          <tr><td>Size: 
          <td><input type="number" min="1" max="9999" value="400" maxlength="4" size="4" id="generate_wx">
          <td><input type="number" min="1" max="512" value="128" maxlength="3" size="3" id="generate_wy">
          <td><input type="number" min="1" max="9999" value="400" maxlength="4" size="4" id="generate_wz">
          <tr><th><th>W<th>H<th>L
        </table>
        <script>config.generate_wx.bindControl("generate_wx");</script>
        <script>config.generate_wy.bindControl("generate_wy");</script>
        <script>config.generate_wz.bindControl("generate_wz");</script>
        <div style="text-align: center;">
          <button onclick="
            worldH = generateWorlds();
            player.setWorld(worldH);
            return false;
          ">Generate new world</button>
        </div>
      </form>

      <h2>Options</h2>

      <form onsubmit="return false;" action="">
        <div class="optionline">Field of view: <input type="range" min="45" max="140" value="60" maxlength="4" size="4" id="fov"></div>
        <script>config.fov.bindControl("fov");</script>
        <div class="optionline">Draw distance: <input type="range" min="10" max="500" value="100" maxlength="4" size="4" id="renderDistance"></div>
        <script>config.renderDistance.bindControl("renderDistance");</script>
        <div class="optionline"><label><input type="checkbox" id="lighting"> Lighting</label></div>
        <script>config.lighting.bindControl("lighting");</script>
        <div class="optionline"><label><input type="checkbox" id="bumpMapping"> Bump mapping</label></div>
        <script>config.bumpMapping.bindControl("bumpMapping");</script>
        
        <h3>Debug</h3>
        
        <div class="optionline"><label><input type="checkbox" id="debugTextureAllocation"> Display block texture</label></div>
        <script>config.debugTextureAllocation.bindControl("debugTextureAllocation");</script>
        <div class="optionline"><label><input type="checkbox" id="debugForceRender"> Always render frames</label></div>
        <script>config.debugForceRender.bindControl("debugForceRender");</script>

        <p><button onclick="resetAllOptions(); return false;">Reset to defaults</button></p>
      </form>
    </div>

    <div id="help" class="sidebar" onclick="this.style.display='none'; document.getElementById('helpbtn').style.display='inline'; document.getElementById('view-canvas').focus();" style="display: none;">
      <h2>Help</h2>
      
      <p>Click to close this help.</p>
      
      <h3>Controls</h3>
      
      <table class="fancy">
        <tr><th colspan=2>Movement
        <tr><td><kbd>W</kbd> <kbd>A</kbd> <kbd>S</kbd> <kbd>D</kbd><br> or arrows<td>move horizontally
        <tr><td><kbd>Space</kbd><td>jump
        <tr><td><kbd>E</kbd><td>fly, move up
        <tr><td><kbd>C</kbd><td>land, move down
        <tr><td>Mouse motion<td>look/target block
        <tr><td>Mouseover<br>left/right edge<td>turn
        <tr><th colspan=2>Blocks
        <tr><td>Left button<td> Place/remove block
        <tr><td>Right button<td> Choose tool from menu
        <tr><td><kbd>R</kbd><td> Edit targeted block
        <tr><td><kbd>F</kbd><td> Exit editing
        <tr><td><kbd>1</kbd>–<kbd>9</kbd>, <kbd>0</kbd><td>Choose tool
      </table>
            
      <p>In the menu of blocks, the empty square at the top left is the removal tool.</p>

      <p>While you can edit any block to any shape, note that making the first block type (which makes up the underground volume in the default world) a non-cubical shape will likely be fatal to your frame rate.</p>

      <h3>Compatibility &amp; Bugs</h3>
      
      <p>Player movement does not work on Safari 5.1. Right mouse button does not work on Firefox 6.0.2.</p>
      
      <p>You can get stuck by placing a block that intersects yourself.</p>

    </div>
</body>

</html>
