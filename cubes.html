<!--
   Except as noted,
   Copyright 2011 Kevin Reid, under the terms of the MIT License as detailed in
   the accompanying file README.md or <http://opensource.org/licenses/MIT>.
  
   Exception: The overall structure of WebGL initialization and context
   management is copied from Learning WebGL, Lesson 16, at
   http://learningwebgl.com/blog/?p=1786 (as of September 2011). No license is
   stated on that site, but I (Kevin Reid) believe that it is obviously the
   authors' intent to make this code free to use.
-->
<!doctype html>
<html><head>
<title>Cube Game</title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

<style type="text/css" media="screen">
  /* ensure that our viewport canvas fills the window */
  html, body, .viewport { margin: 0; border: 0; width: 100%; height: 100%; }
  
  html {
    background: gray; /* ordinarily invisible, but makes initial loading better */
  }
  
  .viewport {
    display: block; /* avoid invoking CSS line layout. */
    cursor: crosshair;
  }
  
  #info {
    position: absolute;
    left: 1px;
    top: 1px;
    
    font-family: monospace;
    color: white;
    text-shadow: 0 0 .3em #000;
    margin: 0 0;
    display: table;
  }
  
  #menu {
    position: fixed;
    background: gray;
    background: rgba(0, 0, 0, 0.5);
    border-radius: 5px;
    display: table;
  }
  #menu canvas {
    margin: 1px 1px;
  }
  #menu .selectedTool {
    border-radius: 5px;
    margin: -1px -1px; /* outlines don't have radius */
    border: 2px solid white;
    background: gray;
  }
  
  .error-notice {
    position: absolute;
    top: 5em;
    right: 50%;
    margin-right: -17em;
    
    z-index: 1;
    border-radius: 2em;
    text-align: center;
    max-width: 30em;
    padding: 1em 2em;
    border: .2em solid red;
    
    background: white;
    color: black;
    font-family: 'Lucida Grande', sans-serif;
  }
  
  #helpbtn {
    position: absolute;
    top: 6px;
    right: 6px;
  }
  #help {
    position: absolute;
    top: 0px;
    right: 0px;
    width: 16em;
    max-height: 100%;
    overflow: auto;
    color: white;
    background: black;
    background: rgba(0,0,0,0.9);
    padding: 0 0.8em;
  }
</style>

<script type="text/javascript" src="webgl-debug.js"></script>
<script type="text/javascript" src="webgl-utils.js"></script>
<script type="text/javascript" src="glMatrix.js"></script>
<script type="text/javascript" src="util.js"></script>
<script type="text/javascript" src="blockset.js"></script>
<script type="text/javascript" src="world.js"></script>
<script type="text/javascript" src="world-render.js"></script>
<script type="text/javascript" src="block-render.js"></script>
<script type="text/javascript" src="player.js"></script>
<script type="text/javascript" src="input.js"></script>

<script id="shader-fs" type="x-shader/x-fragment">
    #ifdef GL_ES
    precision highp float;
    #endif
    
    varying vec4 vColor;
    varying vec3 vFixedOrientationPosition;
    varying vec2 vTextureCoord;
    varying float vFog;

    uniform mat4 uPMatrix;
    uniform mat4 uMVMatrix;
    uniform bool uTextureEnabled;
    uniform sampler2D uSampler;
    
    const vec4 cSky = vec4(0.1,0.3,0.5,1.0);   
    const vec4 cHorizon = vec4(0.7,0.8,1.0,1.0);  
    const vec4 cGround = vec4(0.5,0.4,0.4,1.0);

    void main(void) {
        vec4 color;
        if (uTextureEnabled) {
          // If texturing is enabled, input vertex color is ignored.
          color = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));

          // alpha test
          if (color.a <= 0.0)
            discard;
        } else {
          color = vColor;
        }
        float elevationSine = vFixedOrientationPosition.y / length(vFixedOrientationPosition); // TODO move out of frag
        vec4 fogColor = elevationSine < 0.0
          ? mix(cHorizon, cGround, clamp(log(1.0 + -elevationSine * 120.0), 0.0, 1.0))
          : mix(cHorizon, cSky, clamp(log(1.0 + elevationSine * 2.0), 0.0, 1.0));
        gl_FragColor = color * (1.0-vFog) + fogColor * vFog;
    }
</script>

<script id="shader-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec4 aVertexColor;
    attribute vec2 aTextureCoord;

    uniform bool uTextureEnabled;
    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;
    uniform vec3 uViewPosition;
    
    varying vec4 vColor;
    varying vec3 vFixedOrientationPosition;
    varying vec2 vTextureCoord;
    varying float vFog;
    
    void main(void) {
        vFixedOrientationPosition = aVertexPosition - uViewPosition;
        vec4 relativePosition = uMVMatrix * vec4(aVertexPosition, 1.0);
        gl_Position = uPMatrix * relativePosition;
        
        vTextureCoord = aTextureCoord;
        
        float distanceForFog = length(vec3(relativePosition))/160.0; // should range 0..1. TODO: use clip distance used in projection matrix
        vFog = clamp(pow(distanceForFog, 4.0), 0.0, 1.0);
        vColor = aVertexColor;
    }
</script>


<script type="text/javascript">
    "use strict";
    
    var DEBUG = false;

    var gl;
    var theCanvas;
    var theInfo;
    
    function initGL(canvas) {
        gl = canvas.getContext("experimental-webgl", {
          antialias: false // MORE FILLRATE!!!
        });
        if (DEBUG) {
          gl = WebGLDebugUtils.makeDebugContext(gl);
        } else {
          WebGLDebugUtils.init(gl);
        }
        if (!gl) {
            if (typeof console !== 'undefined') console.log("failed to get context: ", gl);
        }
    }


    function getShader(gl, id) {
        var shaderScript = document.getElementById(id);
        if (!shaderScript) {
            return null;
        }

        var str = "";
        var k = shaderScript.firstChild;
        while (k) {
            if (k.nodeType == 3) {
                str += k.textContent;
            }
            k = k.nextSibling;
        }

        var shader;
        if (shaderScript.type == "x-shader/x-fragment") {
            shader = gl.createShader(gl.FRAGMENT_SHADER);
        } else if (shaderScript.type == "x-shader/x-vertex") {
            shader = gl.createShader(gl.VERTEX_SHADER);
        } else {
            return null;
        }

        gl.shaderSource(shader, str);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            if (typeof console !== 'undefined')
              console.error(gl.getShaderInfoLog(shader));
            throw new Error("Could not compile shader");
        }

        return shader;
    }

    // prepareProgram fills in these with the locations
    var attribs = {
      aVertexPosition: null,
      aVertexColor: null,
      aTextureCoord: null
    };
    var uniforms = {
      uPMatrix: null,
      uMVMatrix: null,
      uViewPosition: null,
      uSampler: null,
      uTextureEnabled: null
    };

    var mvMatrix = mat4.create();
    var pMatrix = mat4.create();
    var viewPosition = vec3.create();

    function setMatrixUniforms() {
        gl.uniformMatrix4fv(uniforms.uPMatrix, false, pMatrix);
        gl.uniformMatrix4fv(uniforms.uMVMatrix, false, mvMatrix);
        gl.uniform3fv(uniforms.uViewPosition, viewPosition);
    }

    function updateViewport() {
      var pagePixelWidth = parseInt(window.getComputedStyle(theCanvas,null).width);
      var pagePixelHeight = parseInt(window.getComputedStyle(theCanvas,null).height);
      
      // Specify canvas resolution
      theCanvas.width = pagePixelWidth;
      theCanvas.height = pagePixelHeight;
      
      // WebGL is not guaranteed to give us that resolution; instead, what it
      // can supply is returned in .drawingBuffer{Width,Height}. However, those
      // properties are not supported by, at least, Firefox 6.0.2.
      if (!("drawingBufferWidth" in gl)) {
        gl.drawingBufferWidth = pagePixelWidth;
        gl.drawingBufferHeight = pagePixelHeight;
      }
      
      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
      mat4.perspective(45, gl.drawingBufferWidth / gl.drawingBufferHeight, 0.1, 160.0, pMatrix);
    }
    
    var worldH;
    function generateInitialWorlds() {
      var blockWorldSize = [World.TILE_SIZE,World.TILE_SIZE,World.TILE_SIZE];
      var blockWorldCount = 5;
      var blockWorlds = [];
      for (var i = 0; i < blockWorldCount; i++) blockWorlds.push(new World(blockWorldSize, BlockSet.colors));

      // big world
      worldH = new World([600,128,600], BlockSet.newTextured(blockWorlds));
      var wx = worldH.wx;
      var wy = worldH.wy;
      var wz = worldH.wz;
      var mid = wy / 2;
      var sin = Math.sin;
      var round = Math.round;
      // Using raw array access because it lets us cache the altitude computation, not because the overhead of .edit() is especially high.
      var raw = worldH.raw;
      for (var x = 0; x < wx; x++) {
        var xbase = x*wy*wz;
        for (var z = 0; z < wz; z++) {
          var terrain = mid + round(
            (Math.sin(x/8) + Math.sin(z/8))*1
            + (Math.sin(x/14) + Math.sin(z/14))*3
            + (Math.sin(x/2) + Math.sin(z/2))*0.6
          );
          for (var y = 0; y < wy; y++) {
            var index = xbase + y*wz + z;
            var altitude = y - terrain;
            raw[index] = altitude > 1 ? 0 :
                         altitude < 0 ? 1 :
                         altitude == 0 ? 2 :
                         /* altitude == 1 */ Math.random() > 0.99 ? 4 : 0;
          }
        }
      }
      
      // --- block worlds ---

      function brgb(r,g,b) {
        return (((b * 3) << 4) + ((g * 3) << 2) + (r * 3) << 0) || 0xC0;
      }
      
      function genv(x,y,z) {
        var v = {
          x: x,
          y: y,
          z: z,
          te: y == 15 ?1:0,
          tp: y == 14 ?1:0,
          be: y == 0 ?1:0,
          bp: y == 1 ?1:0,
          se: (z == 0 || z == 15 || x == 0 || x == 15) ?1:0,
          sp: (z == 1 || z == 14 || x == 1 || x == 14) ?1:0
        };
        v.s = v.te + v.be + v.se;
        v.e = v.s > 1 ?1:0;
        v.c = v.s > 2 ?1:0;
        return v;
      }
      
      function pick(a) {
        return a[Math.floor(Math.random() * a.length)];
      }
      function pickColor() {
        return Math.floor(Math.random() * 256);
      }
      function pickCond(p1, p2) {
        var c = pick(["te","tp","be","bp","se","sp","s","e","c"]);
        return function (v) { return v[c] ? p1(v) : p2(v); }
      }
      
      function flat(color) {
        return function (v) { return color; }
      }
      function rgbPat(v) { return brgb(v.x/16*1.34,v.y/16*1.34,v.z/16*1.34); }
      function speckle(p1, p2) {
        return function (v) {
          return (Math.floor(v.x/4) + v.y + Math.floor(v.z/2)) % 4 ? p1(v) : p2(v);
        };
      }
      
      function genedit(world, patfunc) {
        world.edit(function (x,y,z,value) {
          return patfunc(genv(x,y,z));
        });
      }
      
      genedit(blockWorlds[0], function (v) {
        //return ((v.te||v.be||v.se) ? rgbPat : flat(0))(v);
        return rgbPat(v);
      });
      
      genedit(blockWorlds[1], function (v) {
        return (v.te ? speckle(flat(brgb(.67,.34,.34)), flat(brgb(.67,0,0))) :
                v.tp ? flat(brgb(1,.34,.34)) :
                speckle(flat(brgb(.34,0,0)), flat(brgb(0,0,0))))(v);
      });
      
      genedit(blockWorlds[2], function (v) {
        return v.s ? speckle(flat(0), flat(brgb(0,1,0)))(v) : 0;
      });

      genedit(blockWorlds[3], function (v) {
        return Math.abs(v.x - 8) + Math.abs(v.z - 8) <= 16-v.y ? v.y/2 : 0;
      });
      
      genedit(blockWorlds[4], function (v) {
        return Math.max(Math.abs(v.x - 8), Math.abs(v.z - 8)) <= 4 ? 18 : 0;
      });
      
      for (var i = 5; i < blockWorldCount; i++) {
        var c = pickCond(flat(pickColor()), 
                  pickCond(flat(pickColor()), 
                    speckle(flat(pickColor()), flat(pickColor()))));
        genedit(blockWorlds[i], c);
      }
    }
    
    var cubeSelection = null;
    var emptySelection = null;
    
    function raycastFromScreen(radius, callback) {
      var pos = input.getMousePos();
      var glxy = [pos[0] / theCanvas.width * 2 - 1, -(pos[1] / theCanvas.height * 2 - 1)];
      
      var unproject = mat4.identity(mat4.create());
      player.render.applyViewPitch(unproject);
      player.render.applyViewRotTranslation(unproject);
      mat4.multiply(pMatrix, unproject, unproject);
      mat4.inverse(unproject);

      var pt1 = fixedmultiplyVec3(unproject, vec3.create([glxy[0], glxy[1], 0]));
      var pt2 = fixedmultiplyVec3(unproject, vec3.create([glxy[0], glxy[1], 1]));
      
      return player.getWorld().raycast(pt1, pt2, radius, callback);
    }
    
    function RenderBundle(primitive, optTexture, calcFunc) {
      var vbuf = gl.createBuffer();
      var cbuf = gl.createBuffer();
      if (optTexture) var tbuf = gl.createBuffer();
      var numVertices;
      
      this.recompute = function () {
        var vertices = [];
        var colors = optTexture ? null : [];
        var texcoords = optTexture ? [] : null;
        calcFunc(vertices, optTexture ? texcoords : colors);
        numVertices = Math.floor(vertices.length / 3);

        gl.bindBuffer(gl.ARRAY_BUFFER, vbuf);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

        if (optTexture) {
          gl.bindBuffer(gl.ARRAY_BUFFER, tbuf);
          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texcoords), gl.STATIC_DRAW);
        } else {
          gl.bindBuffer(gl.ARRAY_BUFFER, cbuf);
          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
        }
      };
      
      this.draw = function () {
        gl.bindBuffer(gl.ARRAY_BUFFER, vbuf);
        gl.vertexAttribPointer(attribs.aVertexPosition, 3, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, cbuf);
        gl.vertexAttribPointer(attribs.aVertexColor, 4, gl.FLOAT, false, 0, 0);

        gl.uniform1i(uniforms.uTextureEnabled, optTexture ? 1 : 0);

        if (optTexture) {
          gl.enableVertexAttribArray(attribs.aTextureCoord);
          gl.disableVertexAttribArray(attribs.aVertexColor);
          
          gl.bindBuffer(gl.ARRAY_BUFFER, tbuf);
          gl.vertexAttribPointer(attribs.aTextureCoord, 2, gl.FLOAT, false, 0, 0);
  
          gl.activeTexture(gl.TEXTURE0);
          gl.bindTexture(gl.TEXTURE_2D, optTexture);
          gl.uniform1i(uniforms.uSampler, 0);
        } else {
          gl.disableVertexAttribArray(attribs.aTextureCoord);
          gl.enableVertexAttribArray(attribs.aVertexColor);
        }
        setMatrixUniforms();
        gl.drawArrays(primitive, 0, numVertices);
      };
      
      this.deleteResources = function () {
        gl.deleteBuffer(vbuf);
        gl.deleteBuffer(cbuf);
        if (tbuf) gl.deleteBuffer(tbuf);
        vbuf = cbuf = tbuf = numVertices = null;
      }
      
      this.recompute();
    }

    var debugR;
    var selectionR;
    var backdropR;
    
    function initBuffers() {
      debugR = new RenderBundle(gl.LINES, null, function (vertices, colors) {
        if (player) player.renderDebug(vertices,colors);
      });
      
      backdropR = new RenderBundle(gl.TRIANGLE_STRIP, null, function (vertices, colors) {
        var x = 500, y = 160, z = -160; // within the backdrop clip dist, outside the normal clip (fog) distance
        vertices.push(-x, -y, -z);
        vertices.push(x, -y, -z);
        vertices.push(-x, -y, z);
        vertices.push(x, -y, z);
        vertices.push(-x, y, z);
        vertices.push(x, y, z);
        vertices.push(-x, y, -z);
        vertices.push(x, y, -z);
        
        colors.push(1, 0, 0, 1);
        colors.push(1, 0, 0, 1);
        colors.push(1, 0, 0, 1);
        colors.push(1, 0, 0, 1);
        colors.push(1, 0, 0, 1);
        colors.push(1, 0, 0, 1);
        colors.push(1, 0, 0, 1);
        colors.push(1, 0, 0, 1);
      });

      selectionR = new RenderBundle(gl.LINE_LOOP, null, function (vertices, colors) {
        var p = vec3.create(cubeSelection);
        var q = emptySelection;
        if (cubeSelection !== null && emptySelection !== null) {
          // This works, but don't ask me to justify it. We're taking the vector between the two selection points and deriving a selection box for the face.
          
          var qp = vec3.subtract(p, q, vec3.create()); // face-direction vector
          var qr = [-qp[1], -qp[2], -qp[0]]; // first perpendicular vector 
          var qs = vec3.cross(qp, qr, vec3.create()); // second perpendicular vector
          
          if (qp[0]+qp[1]+qp[2] > 0)
            vec3.subtract(p, qr);
          else
            vec3.subtract(p, qp);
          
          colors.push(1,1,1,1); vertices.push(p[0],p[1],p[2]);
          colors.push(1,1,1,1); vertices.push(p[0]+qr[0],p[1]+qr[1],p[2]+qr[2]);
          colors.push(1,1,1,1); vertices.push(p[0]+qr[0]+qs[0],p[1]+qr[1]+qs[1],p[2]+qr[2]+qs[2]);
          colors.push(1,1,1,1); vertices.push(p[0]+qs[0],p[1]+qs[1],p[2]+qs[2]);
        } else if (cubeSelection !== null) {
          // TODO: Would like to throw this out, but can't because currently if you are outside the world grid there is no emptySelection.
          vertices.push(p[0], p[1], p[2]); colors.push(1, 1, 1, 1);
          vertices.push(p[0], p[1]+1, p[2]); colors.push(1, 1, 1, 1);
          vertices.push(p[0]+1, p[1]+1, p[2]); colors.push(1, 1, 1, 1);
          vertices.push(p[0]+1, p[1], p[2]); colors.push(1, 1, 1, 1);
          vertices.push(p[0]+1, p[1], p[2]+1); colors.push(1, 1, 1, 1);
          vertices.push(p[0]+1, p[1]+1, p[2]+1); colors.push(1, 1, 1, 1);
          vertices.push(p[0], p[1]+1, p[2]+1); colors.push(1, 1, 1, 1);
          vertices.push(p[0], p[1], p[2]+1); colors.push(1, 1, 1, 1);
        }
      });
    }
    
    var player;

    var lastGLErrors = [];
    function drawScene(playerRender) {
        var wrend = playerRender.getWorldRenderer();
      
        mat4.identity(mvMatrix);
        playerRender.applyViewPitch(mvMatrix);
        viewPosition = [0,0,0];

        // TODO: remove duplication of this computation (3)
        mat4.perspective(45, gl.drawingBufferWidth / gl.drawingBufferHeight, 0.1, 1000.0, pMatrix); // longer clipping distance so that backdrop is not clipped

        gl.disable(gl.DEPTH_TEST);
        backdropR.draw(); // dummy geometry to cause shader to render background as fully-fogged
        gl.enable(gl.DEPTH_TEST);
        gl.clear(gl.DEPTH_BUFFER_BIT);

        mat4.perspective(45, gl.drawingBufferWidth / gl.drawingBufferHeight, 0.1, 160.0, pMatrix);

        viewPosition = playerRender.getPosition();
        playerRender.applyViewRotTranslation(mvMatrix);
        wrend.draw();

        debugR.draw();

        gl.disable(gl.DEPTH_TEST);
        selectionR.draw();
        gl.enable(gl.DEPTH_TEST);
        
        var e, errs = [];
        while (e = gl.getError()) {
          errs.push(e);
        }
        
        var text = "";
        {
          var pp = viewPosition;
          var d = 2;
          text += "XYZ: " + pp[0].toFixed(d) + "," + pp[1].toFixed(d) + "," + pp[2].toFixed(d) + "\n";
        }
        text += "Selected: " + cubeSelection + "  Empty: " + emptySelection + "\n";
        if (errs.length) {
          lastGLErrors = errs;
          text += "GL errors:";
          errs.forEach(function (e) {
            text += " " + WebGLDebugUtils.glEnumToString(e);
          });
          text += "\n";
        } else if (lastGLErrors.length) {
          text += "Previous GL errors:";
          lastGLErrors.forEach(function (e) {
            text += " " + WebGLDebugUtils.glEnumToString(e);
          });
          text += "\n";
        }
        text += fpsDesc + "\n";
        text += wrend.debugText();
        theInfo.data = text;
        
        renderCount++;
    }
    
    var timestep = 1/30;
    var input;
    var fpsDesc = "", frameCount = 0, renderCount = 0, chunkRenders = 0;
    
    function doStep() {
      player.stepYourselfAndWorld();
      input.step();
    }
    
    var animFrameWasRequested = false;
    function scheduleDraw() {
      if (!animFrameWasRequested) {
        window.requestAnimFrame(function () {
          animFrameWasRequested = false;
          frameCount++;

          // done here because chunk updating should be deprioritized at the same time drawing would be
          chunkRenders += player.render.getWorldRenderer().updateSomeChunks();

          drawScene(player.render);
        }, theCanvas);
        animFrameWasRequested = true;
      }
    }

    // statistics are reset once per second
    setInterval(function () {
      var idle = frameCount - renderCount;
      fpsDesc = "FPS: " + frameCount + (idle > 0 ? " (" + idle + " idle)" : "") + ", " + chunkRenders + " chunk renders";
      frameCount = renderCount = chunkRenders = 0;
    }, 1000);
    
    // for making our loading more async
    var ABORT = {};
    function sequence(actions, catcher) {
      var t0 = undefined;
      function sub(i) {
        if (i >= actions.length) {
          return;
        } else {
          setTimeout(function () {
            var a = actions[i];
            if (typeof a == 'string') {
              var t1 = Date.now();
              theInfo.data += a + "\n";
              if (typeof console !== 'undefined')
                console.log(t0 ? "(+"+(t1-t0)+" ms)" : "        ", a);
              t0 = t1;
            } else {
              try {
                if (actions[i]() === ABORT) return;
              } catch (e) {
                catcher(e);
              }
            }
            sub(i+1);
          }, 1);
        }
      }
      sub(0);
    }

    function webGLStart() {
      var info = document.getElementById('info');
      while (info.firstChild) info.removeChild(info.firstChild);
      theInfo = document.createTextNode("");
      info.appendChild(theInfo);
      theInfo.data = "";

      sequence([
        "Preparing WebGL...",
        function () {
          theCanvas = document.getElementById('view-canvas');
          initGL(theCanvas);
          if (!gl) {
            document.getElementById("webgl-error-notice").style.removeProperty("display");
            return ABORT;
          }
        },
        "Generating worlds...",
        generateInitialWorlds,
        function () {
          updateViewport();
          window.addEventListener("resize", function () {
            updateViewport();
            return true;
          }, false);
        },
        "Compiling shaders...",
        function () {
          prepareProgram(gl, getShader(gl, "shader-vs"), getShader(gl, "shader-fs"), attribs, uniforms);
          initBuffers();
          gl.enable(gl.DEPTH_TEST);
          gl.enable(gl.CULL_FACE);
        },
        "Painting blocks...", // this is what takes the time in world renderer construction
        function () {
          // done after some GL init because player creates world renderer object internally
          player = new Player(worldH);
          player.setPosition([worldH.wx/2, worldH.wy/2 + 10, worldH.wz/2]);
        },
        "Finishing...",
        function () {
          input = new Input(theCanvas, player.input, document.getElementById("menu"));
          theCanvas.focus();

          // TODO: use webgl utils to avoid wasting time rendering frames if invisible
          setInterval(doStep, 1000*timestep);
        },
        "Ready!"
      ], function (exception) {
        theInfo.data += exception;
        document.getElementById("load-error-notice").style.removeProperty("display");
        document.getElementById("load-error-text").appendChild(document.createTextNode("" + exception));
        throw exception; // propagate to browser console
      });
    }

</script>


</head>


<body onload="webGLStart();">
    <canvas id="view-canvas" tabindex="0" class="viewport" width="640" height="480">
      <div class="error-notice">
        <p>Sorry, but the web browser you are using does not appear to support WebGL (or even Canvas).</p>
      </div>
    </canvas>
    <pre id="info">Not ready...</pre>
    <div id="menu" style="visibility: hidden; left: 1px; top: 1px;">
      <!-- arbitrary initial position -->
    </div>
    <div id="webgl-error-notice" class="error-notice" style="display: none;">
      <p>Sorry, the web browser you are using does not appear to support WebGL.</p>
    </div>
    <div id="load-error-notice" class="error-notice" style="display: none;">
      <p>Sorry, but there was an unexpected error while loading the game.</p>
      <p><pre id="load-error-text" style="white-space: pre-wrap;"></pre></p>
    </div>
    <button id="helpbtn" onclick="this.style.display='none'; document.getElementById('help').style.display='block'; document.getElementById('view-canvas').focus();">Help</button>
    <div id="help" onclick="this.style.display='none'; document.getElementById('helpbtn').style.display='inline'; document.getElementById('view-canvas').focus();" style="display: none;">
      <h2 style="display: none;">Help</h2>
      
      <p>Click to close this help.</p>
      
      <h3>Controls</h3>
      
      <p>Standard W A S D keys or arrow keys to move horizontally. Spacebar to jump or E and C to accelerate vertically. Turn by moving the cursor close to the edges of the window. (Sorry, can't capture the mouse in a web browser.)</p>
      
      <p>Blocks are selected using the mouse. The left button adds or removes blocks at the location of the white rectangle cursor; the right button brings up a menu for choosing blocks (the empty square at the top left is the removal tool).</p>

      <p>The R key enters the world of the selected block; the F key exits out to the previous world. While you can edit any block to any shape, note that making the first block type, which makes up the underground volume, a non-cubical shape will likely be fatal to your frame rate. The terrain surface is also somewhat dangerous in this way.</p>

      <h3>Compatibility &amp; Bugs</h3>
      
      <p>Player movement does not work on Safari 5.1. Right mouse button does not work on Firefox 6.0.2.</p>
      
      <p>The physics is still glitchy, and you can get permanently stuck simply by placing a block where you are.</p>

    </div>
</body>

</html>
