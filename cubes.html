<html>

<head>
<title>Cube Game</title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

<style type="text/css" media="screen">
  html, body, .viewport { margin: 0; border: 0; width: 100%; height: 100%; }
  .viewport {
    cursor: crosshair;
  }
  
  #info {
    position: absolute;
    left: 1px;
    top: 1px;
    
    font-family: monospace;
    color: white;
    text-shadow: 0 0 .1em #0ff;
    margin: 0 0;
    display: table;
  }
  
  #menu {
    position: fixed;
    background: gray;
    background: rgba(0, 0, 0, 0.5);
    border-radius: 5px;
    display: table;
  }
  #menu canvas {
    margin: 1px 1px;
  }
  #menu .selectedTool {
    border-radius: 5px;
    margin: -1px -1px; /* outlines don't have radius */
    border: 2px solid white;
    background: gray;
  }
  
</style>

<script src="webgl-debug.js"></script>
<script type="text/javascript" src="glMatrix.js"></script>
<script type="text/javascript" src="util.js"></script>
<script type="text/javascript" src="blockset.js"></script>
<script type="text/javascript" src="world.js"></script>
<script type="text/javascript" src="world-render.js"></script>
<script type="text/javascript" src="block-render.js"></script>
<script type="text/javascript" src="player.js"></script>
<script type="text/javascript" src="input.js"></script>

<script id="shader-fs" type="x-shader/x-fragment">
    #ifdef GL_ES
    precision highp float;
    #endif
    
    varying vec4 vColor;
    varying vec4 vP;
    varying vec2 vTextureCoord;
    varying float vFog;

    uniform bool uTextureEnabled;
    uniform sampler2D uSampler;
    
    const vec4 cFog = vec4(0.2,0.2,0.5,1.0); // TODO: make this a parameter

    void main(void) {
        // If texturing, then vColor is the color *before* fog; if not, vColor is the color *after* fog.
        if (uTextureEnabled) {
          // TODO: Do we actually need colorization of textures for our purposes?
          gl_FragColor = vColor * texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t)) * (1.0-vFog)
                       + cFog * vFog;
        } else {
          gl_FragColor = vColor;
        }
    }
</script>

<script id="shader-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec4 aVertexColor;
    attribute vec2 aTextureCoord;

    uniform bool uTextureEnabled;
    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;
    
    varying vec4 vColor;
    varying vec4 vP;
    varying vec2 vTextureCoord;
    varying float vFog;
    
    const vec4 cFog = vec4(0.2,0.2,0.5,1.0); // TODO: make this a parameter

    void main(void) {
        vP = uMVMatrix * vec4(aVertexPosition, 1.0);
        gl_Position = uPMatrix * vP;
        
        vTextureCoord = aTextureCoord;
        
        float distanceForFog = length(vec3(vP))/160.0; // should range 0..1. TODO: use clip distance used in projection matrix
        vFog = clamp(pow(distanceForFog, 4.0), 0.0, 1.0);
        vColor = uTextureEnabled ? aVertexColor : aVertexColor * (1.0-vFog) + cFog * vFog;
    }
</script>


<script type="text/javascript">
    "use strict";
    
    var DEBUG = false;

    var gl;
    var theCanvas;
    var theInfo;
    
    function initGL(canvas) {
        gl = canvas.getContext("experimental-webgl", {
          antialias: false // MORE FILLRATE!!!
        });
        if (DEBUG) {
          gl = WebGLDebugUtils.makeDebugContext(gl);
        } else {
          WebGLDebugUtils.init(gl);
        }
        if (!gl) {
            console.log("failed to get context: ", gl);
        }
    }


    function getShader(gl, id) {
        var shaderScript = document.getElementById(id);
        if (!shaderScript) {
            return null;
        }

        var str = "";
        var k = shaderScript.firstChild;
        while (k) {
            if (k.nodeType == 3) {
                str += k.textContent;
            }
            k = k.nextSibling;
        }

        var shader;
        if (shaderScript.type == "x-shader/x-fragment") {
            shader = gl.createShader(gl.FRAGMENT_SHADER);
        } else if (shaderScript.type == "x-shader/x-vertex") {
            shader = gl.createShader(gl.VERTEX_SHADER);
        } else {
            return null;
        }

        gl.shaderSource(shader, str);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.error(gl.getShaderInfoLog(shader));
            throw new Error("Could not compile shader");
        }

        return shader;
    }

    // prepareProgram fills in these with the locations
    var attribs = {
      aVertexPosition: null,
      aVertexColor: null,
      aTextureCoord: null
    };
    var uniforms = {
      uPMatrix: null,
      uMVMatrix: null,
      uSampler: null,
      uTextureEnabled: null
    };

    var mvMatrix = mat4.create();
    var pMatrix = mat4.create();

    function setMatrixUniforms() {
        gl.uniformMatrix4fv(uniforms.uPMatrix, false, pMatrix);
        gl.uniformMatrix4fv(uniforms.uMVMatrix, false, mvMatrix);
    }

    function updateViewport() {
      theCanvas.width = parseInt(window.getComputedStyle(theCanvas,null).width);
      theCanvas.height = parseInt(window.getComputedStyle(theCanvas,null).height);
      gl.viewportWidth = theCanvas.width;
      gl.viewportHeight = theCanvas.height;
      
      gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
      mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 160.0, pMatrix);
    }
    
    console.log("Begin worldgen");

    var blockWorldSize = [World.TILE_SIZE,World.TILE_SIZE,World.TILE_SIZE];
    var worldB1 = new World(blockWorldSize, BlockSet.colors);
    var worldB2 = new World(blockWorldSize, BlockSet.colors);
    var worldH = new World([256,64,256], BlockSet.newTextured([worldB1, worldB2]));
        
    // generate initial world contents
    (function () {
      function brgb(r,g,b) {
        return ((b * 3) << 4) + ((g * 3) << 2) + (r * 3) << 0
      }
      
      var wy = worldH.wy;
      worldH.edit(function (x,y,z,value) {
        var altitude = (y-wy/2) - Math.round((Math.sin(x/10) + Math.sin(z/10))*3);
        return altitude == 0 ? 2 : altitude > 0 ? 0 : 1;
      });
      
      var wy = worldB2.wy;
      worldB2.edit(function (x,y,z,value) {
        var altitude = (y-wy/2) - Math.round((Math.sin(x/10) + Math.sin(z/10))*3);
        return y == 15 ? 2 : y == 14 ? 3 : (Math.floor(x/3) + y + Math.floor(z/2)) % 1.5 ? 1 : 0xC0;
      });
      
      var wx = worldB1.wx;
      var wy = worldB1.wy;
      var wz = worldB1.wz;
      worldB1.edit(function (x,y,z,value) {
        var edginess = (x==0||x==15?1:0) + (y==0||y==15?1:0) + (z==0||z==15?1:0);
        return edginess ? brgb(x/16*1.34,y/16*1.34,z/16*1.34) || 0xC0 : 0;
      });
    })();
    
    console.log("End worldgen");

    var cubeSelection = null;
    var emptySelection = null;
    
    function raycastFromScreen(radius, callback) {
      var pos = input.getMousePos();
      var glxy = [pos[0] / gl.viewportWidth * 2 - 1, -(pos[1] / gl.viewportHeight * 2 - 1)];
      
      var unproject = mat4.identity(mat4.create());
      player.render.applyViewTransform(unproject);
      mat4.multiply(pMatrix, unproject, unproject);
      mat4.inverse(unproject);

      var pt1 = fixedmultiplyVec3(unproject, vec3.create([glxy[0], glxy[1], 0]));
      var pt2 = fixedmultiplyVec3(unproject, vec3.create([glxy[0], glxy[1], 1]));
      
      return player.getWorld().raycast(pt1, pt2, radius, callback);
    }
    
    function RenderBundle(primitive, optTexture, calcFunc) {
      var vbuf = gl.createBuffer();
      var cbuf = gl.createBuffer();
      if (optTexture) var tbuf = gl.createBuffer();
      var numVertices;
      
      this.recompute = function () {
        var vertices = [];
        var colors = [];
        var texcoords = optTexture ? [] : null;
        calcFunc(vertices, colors, texcoords);
        numVertices = Math.floor(vertices.length / 3);

        gl.bindBuffer(gl.ARRAY_BUFFER, vbuf);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

        gl.bindBuffer(gl.ARRAY_BUFFER, cbuf);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
        
        if (optTexture) {
          gl.bindBuffer(gl.ARRAY_BUFFER, tbuf);
          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texcoords), gl.STATIC_DRAW);
        }
      };
      
      this.draw = function () {
        gl.bindBuffer(gl.ARRAY_BUFFER, vbuf);
        gl.vertexAttribPointer(attribs.aVertexPosition, 3, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, cbuf);
        gl.vertexAttribPointer(attribs.aVertexColor, 4, gl.FLOAT, false, 0, 0);

        gl.uniform1i(uniforms.uTextureEnabled, optTexture ? 1 : 0);

        if (optTexture) {
          gl.enableVertexAttribArray(attribs.aTextureCoord);
          
          gl.bindBuffer(gl.ARRAY_BUFFER, tbuf);
          gl.vertexAttribPointer(attribs.aTextureCoord, 2, gl.FLOAT, false, 0, 0);
  
          gl.activeTexture(gl.TEXTURE0);
          gl.bindTexture(gl.TEXTURE_2D, optTexture);
          gl.uniform1i(uniforms.uSampler, 0);
        } else {
          gl.disableVertexAttribArray(attribs.aTextureCoord);
        }
        setMatrixUniforms();
        gl.drawArrays(primitive, 0, numVertices);
      };
      
      this.delete = function () {
        gl.deleteBuffer(vbuf);
        gl.deleteBuffer(cbuf);
        if (tbuf) gl.deleteBuffer(tbuf);
        vbuf = cbuf = tbuf = numVertices = null;
      }
      
      this.recompute();
    }

    var debugR;
    var selectionR;
    
    function initBuffers() {
      debugR = new RenderBundle(gl.LINES, null, function (vertices, colors) {
      });
      
      selectionR = new RenderBundle(gl.LINES, null, function (vertices, colors) {
        if (cubeSelection !== null) {
          var p = cubeSelection;
          vertices.push(p[0], p[1], p[2]); colors.push(1, 1, 1, 1);
          vertices.push(p[0], p[1]+1, p[2]); colors.push(1, 1, 1, 1);
          vertices.push(p[0]+1, p[1]+1, p[2]); colors.push(1, 1, 1, 1);
          vertices.push(p[0]+1, p[1], p[2]); colors.push(1, 1, 1, 1);
          vertices.push(p[0]+1, p[1], p[2]+1); colors.push(1, 1, 1, 1);
          vertices.push(p[0]+1, p[1]+1, p[2]+1); colors.push(1, 1, 1, 1);
          vertices.push(p[0], p[1]+1, p[2]+1); colors.push(1, 1, 1, 1);
          vertices.push(p[0], p[1], p[2]+1); colors.push(1, 1, 1, 1);
        }

        if (emptySelection !== null) {
          // TODO: replace this with a face-highlight
          var q = emptySelection;
          vertices.push(q[0]+0.5, q[1]+0.5, q[2]); colors.push(1, 1, 1, 1);
          vertices.push(q[0]+0.5, q[1]+0.5, q[2]+1); colors.push(1, 1, 1, 1);
          vertices.push(q[0]+0.5, q[1], q[2]+0.5); colors.push(1, 1, 1, 1);
          vertices.push(q[0]+0.5, q[1]+1, q[2]+0.5); colors.push(1, 1, 1, 1);
          vertices.push(q[0], q[1]+0.5, q[2]+0.5); colors.push(1, 1, 1, 1);
          vertices.push(q[0]+1, q[1]+0.5, q[2]+0.5); colors.push(1, 1, 1, 1);
        }
      });
    }
    
    var player;

    var lastGLErrors = [];
    function drawScene(wrend) {
        gl.clearColor(0.2,0.2,0.5,1.0); // This is being set every frame because the block renderer changes it. TODO: send to shader for fog
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        
        mat4.identity(mvMatrix);
        player.render.applyViewTransform(mvMatrix);
        wrend.draw();

        debugR.draw();

        gl.disable(gl.DEPTH_TEST);
        selectionR.draw();
        gl.enable(gl.DEPTH_TEST);
        
        var e, errs = [];
        while (e = gl.getError()) {
          errs.push(e);
        }
        
        var text = "";
        {
          var pp = player.getPosition();
          var d = 2;
          text += "XYZ: " + pp[0].toFixed(d) + "," + pp[1].toFixed(d) + "," + pp[2].toFixed(d) + "\n";
        }
        text += "Selected: " + cubeSelection + "  Empty: " + emptySelection + "\n";
        text += wrend.debugText();
        if (errs.length) {
          lastGLErrors = errs;
          text += "GL errors:";
          errs.forEach(function (e) {
            text += " " + WebGLDebugUtils.glEnumToString(e);
          });
          text += "\n";
        } else if (lastGLErrors.length) {
          text += "Previous GL errors:";
          lastGLErrors.forEach(function (e) {
            text += " " + WebGLDebugUtils.glEnumToString(e);
          });
          text += "\n";
        }
        theInfo.data = text;
    }
    
    var timestep = 1/30;
    var needsDraw = true;
    var input;
    
    function doStep() {
      player.step();

      var wrend = player.getWorldRenderer();
      wrend.updateSomeChunks();

      input.step();

      // TODO: As well as skipping rendering, skip the callback entirely
      // if there's nothing to do.
      if (needsDraw) {
        drawScene(wrend);
        needsDraw = false;
      }
    }

    function webGLStart(canvas, info) {
      theCanvas = canvas;
      initGL(canvas);

      while (info.firstChild) info.removeChild(info.firstChild);
      theInfo = document.createTextNode("");
      info.appendChild(theInfo);

      // should do live, but makes Chrome glitchy
      updateViewport();
    
      prepareProgram(getShader(gl, "shader-vs"), getShader(gl, "shader-fs"), attribs, uniforms);
      initBuffers();

      gl.clearColor(0.2,0.2,0.5,1.0); // TODO: send to shader for fog
      gl.enable(gl.DEPTH_TEST);
      gl.enable(gl.CULL_FACE);

      // done after some GL init because player creates world renderer...
      player = new Player(worldH);
      player.setPosition([worldH.wx/2, worldH.wy/2 + 10, worldH.wz/2]);

      // TODO: use webgl utils to avoid wasting time if invisible
      setInterval(doStep, 1000*timestep);

      input = new Input(canvas, player.input);
      canvas.focus();
    }

</script>


</head>


<body onload="webGLStart(document.getElementById('view-canvas'), document.getElementById('info'));">
    <canvas id="view-canvas" tabindex="0" class="viewport" width="640" height="480"></canvas>
    <pre id="info">Loading...</pre>
    
    <div id="menu" style="visibility: hidden;">
    </div>
</body>

</html>
