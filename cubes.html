<html>

<head>
<title>Cube Game</title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

<style type="text/css" media="screen">
  html, body, .viewport { margin: 0; border: 0; width: 100%; height: 100%; }
  .viewport {
    cursor: crosshair;
  }
  
  #info {
    position: absolute;
    left: 1px;
    top: 1px;
    
    font-family: monospace;
    color: white;
    text-shadow: 0 0 .1em #0ff;
    margin: 0 0;
    display: table;
  }
</style>

<script src="webgl-debug.js"></script>
<script type="text/javascript" src="glMatrix.js"></script>
<script type="text/javascript" src="util.js"></script>
<script type="text/javascript" src="blockset.js"></script>
<script type="text/javascript" src="world.js"></script>
<script type="text/javascript" src="player.js"></script>
<script type="text/javascript" src="input.js"></script>

<script id="shader-fs" type="x-shader/x-fragment">
    #ifdef GL_ES
    precision highp float;
    #endif
    
    varying vec4 vColor;
    varying vec4 vP;
    varying vec2 vTextureCoord;
    varying float vFog;

    uniform bool uTextureEnabled;
    uniform sampler2D uSampler;
    
    const vec4 cFog = vec4(0.2,0.2,0.5,1.0); // TODO: make this a parameter

    void main(void) {
        // If texturing, then vColor is the color *before* fog; if not, vColor is the color *after* fog.
        if (uTextureEnabled) {
          // TODO: Do we actually need colorization of textures for our purposes?
          gl_FragColor = vColor * texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t)) * (1.0-vFog)
                       + cFog * vFog;
        } else {
          gl_FragColor = vColor;
        }
    }
</script>

<script id="shader-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec4 aVertexColor;
    attribute vec2 aTextureCoord;

    uniform bool uTextureEnabled;
    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;
    
    varying vec4 vColor;
    varying vec4 vP;
    varying vec2 vTextureCoord;
    varying float vFog;
    
    const vec4 cFog = vec4(0.2,0.2,0.5,1.0); // TODO: make this a parameter

    void main(void) {
        vP = uMVMatrix * vec4(aVertexPosition, 1.0);
        gl_Position = uPMatrix * vP;
        
        vTextureCoord = aTextureCoord;
        
        float distanceForFog = length(vec3(vP))/160.0; // should range 0..1. TODO: use clip distance used in projection matrix
        vFog = clamp(pow(distanceForFog, 4.0), 0.0, 1.0);
        vColor = uTextureEnabled ? aVertexColor : aVertexColor * (1.0-vFog) + cFog * vFog;
    }
</script>


<script type="text/javascript">
    "use strict";
    
    var DEBUG = false;

    var gl;
    var theCanvas;
    var theInfo;
    
    function initGL(canvas) {
        gl = canvas.getContext("experimental-webgl", {
          antialias: false // MORE FILLRATE!!!
        });
        if (DEBUG) {
          gl = WebGLDebugUtils.makeDebugContext(gl);
        } else {
          WebGLDebugUtils.init(gl);
        }
        if (!gl) {
            console.log("failed to get context: ", gl);
        }
    }


    function getShader(gl, id) {
        var shaderScript = document.getElementById(id);
        if (!shaderScript) {
            return null;
        }

        var str = "";
        var k = shaderScript.firstChild;
        while (k) {
            if (k.nodeType == 3) {
                str += k.textContent;
            }
            k = k.nextSibling;
        }

        var shader;
        if (shaderScript.type == "x-shader/x-fragment") {
            shader = gl.createShader(gl.FRAGMENT_SHADER);
        } else if (shaderScript.type == "x-shader/x-vertex") {
            shader = gl.createShader(gl.VERTEX_SHADER);
        } else {
            return null;
        }

        gl.shaderSource(shader, str);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.error(gl.getShaderInfoLog(shader));
            return null;
        }

        return shader;
    }


    var shaderProgram;

    function initShaders() {
        var fragmentShader = getShader(gl, "shader-fs");
        var vertexShader = getShader(gl, "shader-vs");

        shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);

        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            console.error("Could not initialise shaders");
            console.error(gl.getProgramInfoLog(shaderProgram));
        }

        gl.useProgram(shaderProgram);

        shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
        gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);

        shaderProgram.vertexColorAttribute = gl.getAttribLocation(shaderProgram, "aVertexColor");
        gl.enableVertexAttribArray(shaderProgram.vertexColorAttribute);

        shaderProgram.textureCoordAttribute = gl.getAttribLocation(shaderProgram, "aTextureCoord");
        gl.enableVertexAttribArray(shaderProgram.textureCoordAttribute);

        shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
        shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
        shaderProgram.samplerUniform = gl.getUniformLocation(shaderProgram, "uSampler");
        shaderProgram.textureUniform = gl.getUniformLocation(shaderProgram, "uTextureEnabled");
    }


    var mvMatrix = mat4.create();
    var pMatrix = mat4.create();

    function setMatrixUniforms() {
        gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
        gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);
    }

    function updateViewport() {
      theCanvas.width = parseInt(window.getComputedStyle(theCanvas,null).width);
      theCanvas.height = parseInt(window.getComputedStyle(theCanvas,null).height);
      gl.viewportWidth = theCanvas.width;
      gl.viewportHeight = theCanvas.height;
      
      gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
      mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 160.0, pMatrix);
    }
    
    console.log("Begin worldgen");

    // The size of a texture tile, and therefore the size of a block-defining-block
    var TILE_SIZE = 16;
    
    var blockWorldSize = [TILE_SIZE,TILE_SIZE,TILE_SIZE];
    var worldB1 = new World(blockWorldSize, BlockSet.colors);
    var worldB2 = new World(blockWorldSize, BlockSet.colors);
    var worldH = new World([256,16,256], BlockSet.newTextured([worldB1, worldB2]));
    
    var worlds = [worldB1, worldB2, worldH];
    var worldIndex = 2;
    var world = worlds[worldIndex];
    
    // gen block test
    (function () {
      function brgb(r,g,b) {
        return ((b * 3) << 4) + ((g * 3) << 2) + (r * 3) << 0
      }
      
      var wx = worldB1.wx;
      var wy = worldB1.wy;
      var wz = worldB1.wz;
      for (var x = 0; x < wx; x++)
      for (var y = 0; y < wy; y++)
      for (var z = 0; z < wz; z++) {
        var edginess = (x==0||x==15?1:0) + (y==0||y==15?1:0) + (z==0||z==15?1:0);
        worldB1.s(x,y,z, edginess ? brgb(x/16*1.34,y/16*1.34,z/16*1.34) || 0xC0 : 0);
      }
    })();
    
    console.log("End worldgen");

    var cubeSelection = null;
    var emptySelection = null;
    
    function raycastFromScreen(radius, callback) {
      var pos = input.getMousePos();
      var glxy = [pos[0] / gl.viewportWidth * 2 - 1, -(pos[1] / gl.viewportHeight * 2 - 1)];
      
      var unproject = mat4.create();
      mat4.multiply(pMatrix, mvMatrix, unproject);
      mat4.inverse(unproject);

      var pt1 = fixedmultiplyVec3(unproject, vec3.create([glxy[0], glxy[1], 0]));
      var pt2 = fixedmultiplyVec3(unproject, vec3.create([glxy[0], glxy[1], 1]));
      
      return world.raycast(pt1, pt2, radius, callback);
    }
    
    function RenderBundle(primitive, textured, calcFunc) {
      var vbuf = gl.createBuffer();
      var cbuf = gl.createBuffer();
      if (textured) var tbuf = gl.createBuffer();
      var numVertices;
      
      this.recompute = function () {
        var vertices = [];
        var colors = [];
        var texcoords = textured ? [] : null;
        calcFunc(vertices, colors, texcoords);
        numVertices = Math.floor(vertices.length / 3);

        gl.bindBuffer(gl.ARRAY_BUFFER, vbuf);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

        gl.bindBuffer(gl.ARRAY_BUFFER, cbuf);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
        
        if (textured) {
          gl.bindBuffer(gl.ARRAY_BUFFER, tbuf);
          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texcoords), gl.STATIC_DRAW);
        }
      };
      
      this.draw = function () {
        gl.bindBuffer(gl.ARRAY_BUFFER, vbuf);
        gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, 3, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, cbuf);
        gl.vertexAttribPointer(shaderProgram.vertexColorAttribute, 4, gl.FLOAT, false, 0, 0);

        gl.uniform1i(shaderProgram.textureUniform, textured ? 1 : 0);

        if (textured) {
          gl.enableVertexAttribArray(shaderProgram.textureCoordAttribute);
          
          gl.bindBuffer(gl.ARRAY_BUFFER, tbuf);
          gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, 2, gl.FLOAT, false, 0, 0);
  
          gl.activeTexture(gl.TEXTURE0);
          gl.bindTexture(gl.TEXTURE_2D, blockTexture);
          gl.uniform1i(shaderProgram.samplerUniform, 0);
        } else {
          gl.disableVertexAttribArray(shaderProgram.textureCoordAttribute);
        }
        setMatrixUniforms();
        gl.drawArrays(primitive, 0, numVertices);
      };
      
      this.delete = function () {
        gl.deleteBuffer(vbuf);
        gl.deleteBuffer(cbuf);
        if (tbuf) gl.deleteBuffer(tbuf);
        vbuf = cbuf = tbuf = numVertices = null;
      }
      
      this.recompute();
    }

    var CHUNKSIZE = 16;
    var chunks;
    var dirtyChunks;
    
    var debugR;
    var selectionR;
    
    function dirtyBlock(x,z) {
      // TODO: Update neighboring chunks too.
      x -= mod(x, 16);
      z -= mod(z, 16);
      dirtyChunks.push([x,z]); // TODO: de-duplicate
    }
    function depthSortDirty() {
      var pp = player.getPosition();
      dirtyChunks.sort(function (a,b) {
        return (
          Math.pow(b[0]-pp[0],2)+Math.pow(b[1]-pp[2],2)
          - (Math.pow(a[0]-pp[0],2)+Math.pow(a[1]-pp[2],2))
        );
      });
    }
    
    var DUMMY_TILING = Object.freeze({lx:null,ly:null,lz:null,hx:null,hy:null,hz:null});
    function calcChunk(xzkey) {
      if (chunks[xzkey]) {
        chunks[xzkey].recompute();
      } else {
        var wx = world.wx;
        var wy = world.wy;
        var wz = world.wz;
        var chunkOriginX = xzkey[0];
        var chunkOriginZ = xzkey[1];
        var chunkLimitX = xzkey[0] + CHUNKSIZE;
        var chunkLimitZ = xzkey[1] + CHUNKSIZE;
        var blockSet = world.blockSet;
        var textured = blockSet.textured;
        chunks[xzkey] = new RenderBundle(gl.TRIANGLES, textured, function (vertices, colors, texcoords) {
          var pvBuffer = vec3.create();
          function pushVertex(vec) {
            vertices.push(vec[0], vec[1], vec[2]);
          }
          // Given tile coords and u,v within the tile, generate tex coords
          function pushTileCoord(tileKey, u, v) {
            // TODO: optimize this out to constant
            texcoords.push((tileKey[1] + u) / TILE_COUNT_U, 
                           (tileKey[0] + v) / TILE_COUNT_V);
          }

          function square(origin, v1, v2, tileKey, texO, texD, color) {
            // texO and texD are the originward and v'ward texture coordinates, used to flip the texture coords vs. origin for the 'positive side' squares
            
            pushVertex(origin);
            pushVertex(vec3.add(origin, v1, vec3.create()));
            pushVertex(vec3.add(origin, v2, vec3.create()));

            pushVertex(vec3.add(vec3.add(origin, v1, vec3.create()), v2));
            pushVertex(vec3.add(origin, v2, vec3.create()));
            pushVertex(vec3.add(origin, v1, vec3.create()));

            if (textured) {
              pushTileCoord(tileKey, texO, texO);
              pushTileCoord(tileKey, 1, 0);
              pushTileCoord(tileKey, 0, 1);
              pushTileCoord(tileKey, texD, texD);
              pushTileCoord(tileKey, 0, 1);
              pushTileCoord(tileKey, 1, 0);
            }

            for (var i=0; i < 6; i++) {
              colors.push(color[0],color[1],color[2],color[3]);
            }
          }

          var t0 = Date.now();
          var blockSet = world.blockSet;
          var tilings = blockSet.tilings;
          for (var x = chunkOriginX; x < chunkLimitX; x++)
          for (var y = 0;            y < wy         ; y++)
          for (var z = chunkOriginZ; z < chunkLimitZ; z++) {
            var value = world.g(x,y,z);
            var tiling = textured ? blockSet.tilings[Math.min(value - 1, blockSet.tilings.length - 1)] : DUMMY_TILING;
            if (world.solid(x,y,z)) {
              var color = [];
              blockSet.writeColor(value, 1.0, color, 0);
              var tk = [0,0];
              var c1 = [x,y,z];
              var c2 = [x+1,y+1,z+1];
              if (!world.solid(x-1,y,z)) square(c1, [0,0,1],  [0,1,0],  tiling.lx, 0, 1, color);
              if (!world.solid(x,y-1,z)) square(c1, [1,0,0],  [0,0,1],  tiling.ly, 0, 1, color);
              if (!world.solid(x,y,z-1)) square(c1, [0,1,0],  [1,0,0],  tiling.lz, 0, 1, color);
              if (!world.solid(x+1,y,z)) square(c2, [0,-1,0], [0,0,-1], tiling.hx, 1, 0, color);
              if (!world.solid(x,y+1,z)) square(c2, [0,0,-1], [-1,0,0], tiling.hy, 1, 0, color);
              if (!world.solid(x,y,z+1)) square(c2, [-1,0,0], [0,-1,0], tiling.hz, 1, 0, color);
            }
          }
          var t1 = Date.now();
          //console.log("Geometry regen:", t1-t0, "ms");
        });
      }
      needsDraw = true;
    }

    function initBuffers() {
      debugR = new RenderBundle(gl.LINES, false, function (vertices, colors) {
      });
      
      selectionR = new RenderBundle(gl.LINES, false, function (vertices, colors) {
        if (cubeSelection !== null) {
          var p = cubeSelection;
          vertices.push(p[0], p[1], p[2]); colors.push(1, 1, 1, 1);
          vertices.push(p[0], p[1]+1, p[2]); colors.push(1, 1, 1, 1);
          vertices.push(p[0]+1, p[1]+1, p[2]); colors.push(1, 1, 1, 1);
          vertices.push(p[0]+1, p[1], p[2]); colors.push(1, 1, 1, 1);
          vertices.push(p[0]+1, p[1], p[2]+1); colors.push(1, 1, 1, 1);
          vertices.push(p[0]+1, p[1]+1, p[2]+1); colors.push(1, 1, 1, 1);
          vertices.push(p[0], p[1]+1, p[2]+1); colors.push(1, 1, 1, 1);
          vertices.push(p[0], p[1], p[2]+1); colors.push(1, 1, 1, 1);
        }

        if (emptySelection !== null) {
          // TODO: replace this with a face-highlight
          var q = emptySelection;
          vertices.push(q[0]+0.5, q[1]+0.5, q[2]); colors.push(1, 1, 1, 1);
          vertices.push(q[0]+0.5, q[1]+0.5, q[2]+1); colors.push(1, 1, 1, 1);
          vertices.push(q[0]+0.5, q[1], q[2]+0.5); colors.push(1, 1, 1, 1);
          vertices.push(q[0]+0.5, q[1]+1, q[2]+0.5); colors.push(1, 1, 1, 1);
          vertices.push(q[0], q[1]+0.5, q[2]+0.5); colors.push(1, 1, 1, 1);
          vertices.push(q[0]+1, q[1]+0.5, q[2]+0.5); colors.push(1, 1, 1, 1);
        }
      });
      
      rebuildWorld(); // initializes chunk RenderBundles
    }
    
    function rebuildWorld() {
      rebuildBlockTexture();
      
      for (var index in chunks) {
        if (!chunks.hasOwnProperty(index)) continue;
        chunks[index].delete();
      }
      
      chunks = {};
      dirtyChunks = [];
      
      for (var x = 0; x < world.wx; x += CHUNKSIZE)
      for (var z = 0; z < world.wz; z += CHUNKSIZE) (function () {
        dirtyBlock(x, z);
      })();
      depthSortDirty();
    }
    
    var TILE_COUNT_U = 4;
    var TILE_COUNT_V = 4;
    var TILE_MAPPINGS = [
      // in this matrix layout, the input (column) vector is the tile coords
      // and the output (row) vector is the world space coords
      // so the lower row is the translation component.
      ["lz", mat4.create([
        // low z face
        1, 0, 0, 0,
        0, 1, 0, 0,
        0, 0, 0, 0,
        0, 0, 0, 1
      ])],
      ["hz", mat4.create([
        // high z face
        1, 0, 0, 0,
        0, 1, 0, 0,
        0, 0, 0, 0,
        0, 0, 15, 1
      ])],
      ["lx", mat4.create([
        // low x face
        0, 1, 0, 0,
        0, 0, 1, 0,
        0, 0, 0, 0,
        0, 0, 0, 1
      ])],
      ["hx", mat4.create([
        // high x face
        0, 1, 0, 0,
        0, 0, 1, 0,
        0, 0, 0, 0,
        15, 0, 0, 1
      ])],
      ["ly", mat4.create([
        // low y face
        0, 0, 1, 0,
        1, 0, 0, 0,
        0, 0, 0, 0,
        0, 0, 0, 1
      ])],
      ["hy", mat4.create([
        // high y face
        0, 0, 1, 0,
        1, 0, 0, 0,
        0, 0, 0, 0,
        0, 15, 0, 1
      ])],
    ];
    
    var blockTexture;
    var blockTextureData;
    function initTexture() {
      blockTexture = gl.createTexture();
      blockTextureData = document.createElement("canvas").getContext("2d").createImageData(TILE_SIZE * TILE_COUNT_U, TILE_SIZE * TILE_COUNT_V);
      rebuildBlockTexture();
    }
    function rebuildBlockTexture() {
      if (!blockTexture) return;
      
      var data = blockTextureData;
      
      world.blockSet.generateBlockTextures(blockTextureData);
      gl.bindTexture(gl.TEXTURE_2D, blockTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, data);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.bindTexture(gl.TEXTURE_2D, null);
    }
    
    var player = new Player();

    var lastGLErrors = [];
    function drawScene() {
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        mat4.identity(mvMatrix);
        player.render.applyViewTransform(mvMatrix);
        
        for (var index in chunks) {
          if (!chunks.hasOwnProperty(index)) continue;
          chunks[index].draw();
        }

        debugR.draw();

        gl.disable(gl.DEPTH_TEST);
        selectionR.draw();
        gl.enable(gl.DEPTH_TEST);
        
        var e, errs = [];
        while (e = gl.getError()) {
          errs.push(e);
        }
        
        var text = "";
        {
          var pp = player.getPosition();
          var d = 2;
          text += "XYZ: " + pp[0].toFixed(d) + "," + pp[1].toFixed(d) + "," + pp[2].toFixed(d) + "\n";
        }
        text += "Selected: " + cubeSelection + "  Empty: " + emptySelection + "\n";
        if (dirtyChunks.length) {
          text += ("Chunk Q: " + dirtyChunks.length + "\n");
        }
        if (errs.length) {
          lastGLErrors = errs;
          text += "GL errors:";
          errs.forEach(function (e) {
            text += " " + WebGLDebugUtils.glEnumToString(e);
          });
          text += "\n";
        } else if (lastGLErrors.length) {
          text += "Previous GL errors:";
          lastGLErrors.forEach(function (e) {
            text += " " + WebGLDebugUtils.glEnumToString(e);
          });
          text += "\n";
        }
        theInfo.data = text;
    }
    
    var timestep = 1/30;
    var needsDraw = true;
    var input;
    
    function doStep() {
      player.step();
      for (var i = 0; i < 3; i++) {
        if (dirtyChunks.length > 0) {
          calcChunk(dirtyChunks.pop());
        }
      }

      input.step();

      // TODO: As well as skipping rendering, skip the callback entirely
      // if there's nothing to do.
      if (needsDraw) {
        drawScene();
        needsDraw = false;
      }
    }

    function webGLStart(canvas, info) {
      theCanvas = canvas;
      initGL(canvas);

      while (info.firstChild) info.removeChild(info.firstChild);
      theInfo = document.createTextNode("");
      info.appendChild(theInfo);

      // should do live, but makes Chrome glitchy
      updateViewport();
    
      initShaders();
      initBuffers();
      initTexture();

      gl.clearColor(0.2,0.2,0.5,1.0); // TODO: send to shader for fog
      gl.enable(gl.DEPTH_TEST);
      gl.enable(gl.CULL_FACE);

      // TODO: use webgl utils to avoid wasting time if invisible
      setInterval(doStep, 1000*timestep);

      input = new Input(canvas, player.input);
      canvas.focus();
    }

</script>


</head>


<body onload="webGLStart(document.getElementById('view-canvas'), document.getElementById('info'));">
    <canvas id="view-canvas" tabindex="0" class="viewport" width="640" height="480"></canvas>
    <pre id="info">Loading...</pre>
</body>

</html>
