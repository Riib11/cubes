<!--
   Except as noted,
   Copyright 2011 Kevin Reid, under the terms of the MIT License as detailed in
   the accompanying file README.md or <http://opensource.org/licenses/MIT>.
  
   Exception: The overall structure of WebGL initialization and context
   management is copied from Learning WebGL, Lesson 16, at
   http://learningwebgl.com/blog/?p=1786 (as of September 2011). No license is
   stated on that site, but I (Kevin Reid) believe that it is obviously the
   authors' intent to make this code free to use.
-->
<!doctype html>
<html><head>
<title>Cube Game</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="viewport" content="width=device-width">
<link rel="stylesheet" href="style.css" type="text/css">

<script type="text/javascript" src="webgl-debug.js"></script>
<script type="text/javascript" src="webgl-utils.js"></script>
<script type="text/javascript" src="glMatrix.js"></script>
<script type="text/javascript" src="util.js"></script>
<script type="text/javascript" src="blockset.js"></script>
<script type="text/javascript" src="world.js"></script>
<script type="text/javascript" src="world-gen.js"></script>
<script type="text/javascript" src="circuit.js"></script>
<script type="text/javascript" src="renderer.js"></script>
<script type="text/javascript" src="world-render.js"></script>
<script type="text/javascript" src="block-render.js"></script>
<script type="text/javascript" src="player.js"></script>
<script type="text/javascript" src="input.js"></script>
<script type="text/javascript" src="audio.js"></script>

<script id="shader-fs" type="x-shader/x-fragment">
    #ifdef GL_ES
    precision highp float;
    #endif
    
    varying vec4 vColor;
    varying vec3 vGridPosition;
    varying vec3 vFixedOrientationPosition;
    varying vec2 vTextureCoord;
    varying float vFog;
    varying vec3 vNormal;
    varying float vDistanceFromEye;

    uniform mat4 uPMatrix;
    uniform mat4 uMVMatrix;
    uniform bool uTextureEnabled;
    uniform sampler2D uSampler;
    uniform bool uLighting;
    uniform bool uBumpMapping;
    uniform bool uStipple;
    
    const vec4 cSky = vec4(0.1,0.3,0.5,1.0);   
    const vec4 cHorizon = vec4(0.7,0.8,1.0,1.0);  
    const vec4 cGround = vec4(0.5,0.4,0.4,1.0);
    const float cModEpsilon = 1e-20;
    const float cTileCurvature = 0.2;
    const float cTileBumpDistance = 2.0;

    const float cLightAmbient = 0.5;
    const vec3 cLight1Dir = vec3(0.8,-0.2,0);
    const vec3 cLight2Dir = vec3(-0.8,0.7,0.5);

    // What is the illumination from the given (unit vector) direction?
    float lightEnv(vec3 dir) {
      return max(0.0, dot(cLight1Dir, dir)) + max(0.0, dot(cLight2Dir, dir));
    }
    
    // Componentwise x^7. pow() is unsuitable for negative arguments.
    vec3 pow7vec3(vec3 x) {
      vec3 y = x*x*x;
      return y*y*x;
    }

    // Add amount of any component over 1.0 to all components (makes overbright colors turn to white)
    vec3 spill(vec3 v) {
      return v + vec3(max(1.0, max(v.r, max(v.g, v.b))) - 1.0);
    }

    float lighting() {
      // 'cell' is a vector with components in [-1.0, 1.0] indicating this point's
      // offset from the center of its sub-cube
      vec3 normal;
      if (uBumpMapping) {
        vec3 cell = (mod(vGridPosition * float(TILE_SIZE) + cModEpsilon, 1.0) - vec3(0.5)) * 2.0;
        normal = normalize(vNormal + cTileCurvature / max(1.0, vDistanceFromEye / cTileBumpDistance) * pow7vec3(cell));
      } else {
        normal = vNormal;
      }
      return cLightAmbient + lightEnv(normal);
    }
    
    void main(void) {
        if (uStipple && mod(gl_FragCoord.x - gl_FragCoord.y, 2.0) < 1.0)
          discard;
        
        // color/lighting calculation
        // if the vertex normal is zero, then that means "do not use lighting"
        vec4 color = vec4(vec3(vColor) * 
            (!uLighting || vNormal == vec3(0,0,0)
              ? 1.0 
              : lighting()), vColor.a);

        if (uTextureEnabled) {
          color *= texture2D(uSampler, vTextureCoord);

          // alpha test
          if (color.a <= 0.0)
            discard;
        }
        
        color = vec4(spill(vec3(color)), color.a);

        float elevationSine = vFixedOrientationPosition.y / length(vFixedOrientationPosition);
        vec4 fogColor = elevationSine < 0.0
          ? mix(cHorizon, cGround, clamp(log(1.0 + -elevationSine * 120.0), 0.0, 1.0))
          : mix(cHorizon, cSky, clamp(log(1.0 + elevationSine * 2.0), 0.0, 1.0));
        gl_FragColor = color * (1.0-vFog) + fogColor * vFog;
    }
</script>

<script id="shader-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec4 aVertexColor;
    attribute vec3 aVertexNormal;
    attribute vec2 aTextureCoord;

    uniform bool uTextureEnabled;
    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;
    uniform vec3 uViewPosition;
    uniform vec2 uPixelsPerClipUnit;
    uniform float uFogDistance;
    
    uniform bool uParticleMode;     // flag we're rendering point particles
    uniform float uParticleInterp;  // particle system evolution time, [0.0, 1.0]
    uniform bool uParticleExplode; // particles explode or appear/fade?
    
    varying vec4 vColor;
    varying vec3 vGridPosition;
    varying vec3 vFixedOrientationPosition;
    varying vec2 vTextureCoord;
    varying vec3 vNormal;
    varying float vFog;
    varying float vDistanceFromEye;
    
    void main(void) {
        vec3 vertexPosition;
        float pointScale;
        
        if (uParticleMode) {
          // center of block
          vec3 blockPart = floor(aVertexPosition) + 0.5;
          // offset from center of block
          vec3 particlePart = mod(aVertexPosition, 1.0) - 0.5;
          
          // pseudorandom vector constant for the point
          vec3 scramble = normalize(vec3(
            sin(dot(aVertexPosition, vec3(24121.9, 2398.1, 234.8))),
            sin(dot(aVertexPosition, vec3(1024.0, 28.0, 1834.0))),
            sin(dot(aVertexPosition, vec3(486.0, 282.4, 7.215)))
          ));
          
          vertexPosition = uParticleExplode
            ? aVertexPosition + (1.0 * scramble + 0.5 * particlePart) * pow(uParticleInterp, 3.0)
            : aVertexPosition + particlePart * (0.1 + uParticleInterp * 0.1);
          pointScale = 1.0 - pow(uParticleInterp * 1.0, 2.0);
        } else {
          vertexPosition = aVertexPosition;
        }
        
        vGridPosition = vertexPosition;
        vFixedOrientationPosition = vertexPosition - uViewPosition;
        vec4 relativePosition = uMVMatrix * vec4(vertexPosition, 1.0);
        gl_Position = uPMatrix * relativePosition;
        
        if (uParticleMode) {
          // Compute particle size
          vec4 testPosition = relativePosition;
          testPosition.x = uPixelsPerClipUnit.x / float(TILE_SIZE) * 1.2/*appearance fudge factor*/;
          testPosition.y = 0.0;
          testPosition = uPMatrix * testPosition;
          gl_PointSize = testPosition.x / testPosition.w * pointScale;
        }
        
        vTextureCoord = aTextureCoord;
        
        // linear distance from eye, scaled to 1.0 = 100% fog
        vDistanceFromEye = length(vec3(relativePosition));
        
        // fog color mixing parameter
        vFog = clamp(pow(vDistanceFromEye/uFogDistance, 4.0), 0.0, 1.0);
        
        vColor = uTextureEnabled ? vec4(1.0) : aVertexColor;
        vNormal = aVertexNormal;
    }
</script>


<script type="text/javascript">
    "use strict";
    
    var DEBUG = false;
    var TIMESTEP = 1/60;
    var MAX_CATCHUP_MS = 500;
    
    var TIMESTEP_MS = TIMESTEP*1000;
    
    // Settable using the options sidebar
    var config = {};
    function defineOption(name, type, value) {
      config[name] = new PersistentCell("cubes.option." + name, type, value);
    }
    function resetAllOptions() {
      Object.keys(config).forEach(function (k) { config[k].setToDefault(); });
    }
    defineOption("fov", "number", 60);
    defineOption("renderDistance", "number", 100);
    defineOption("lighting", "boolean", true);
    defineOption("bumpMapping", "boolean", true);
    defineOption("sound", "boolean", true);
    defineOption("debugTextureAllocation", "boolean", false);
    defineOption("debugForceRender", "boolean", false);
    defineOption("debugPlayerCollision", "boolean", false);
 
    defineOption("generate_wx", "number", 400);
    defineOption("generate_wy", "number", 128);
    defineOption("generate_wz", "number", 400);
    defineOption("generate_shape", "string", "fill");
    defineOption("generate_slope", "number", 0.9);

    // GL objects
    var gl;
    var theCanvas;
    var renderer;
    
    var sceneInfo;
    var cursorInfoElem;
    var cursorInfo;
    var chunkProgressBar;
    var audioProgressBar;
    
    // Game state, etc. objects
    var player;
    var worldH;
    var input;
    
    var readyToDraw = false;
    
    function raycastFromScreen(radius, callback) {
      var pts = renderer.getAimRay();
      return player.getWorld().raycast(pts[0], pts[1], radius, callback);
    }
    
    var lastGLErrors = [];
    function drawScene(playerRender) {
        var wrend = playerRender.getWorldRenderer();

        renderer.setViewToSkybox(playerRender);
        renderer.skybox.draw();
        gl.clear(gl.DEPTH_BUFFER_BIT);
        
        renderer.setViewToEye(playerRender);
        wrend.draw();
        player.render.characterRender.draw();
        player.render.selectionRender.draw();
        
        var e, errs = [];
        while ((e = gl.getError()) && e != gl.CONTEXT_LOST_WEBGL) {
          errs.push(e);
        }
        // Note: The above comparison is an != rather than !== because webgl-debug.js's wrapped context returns numeric strings (!) instead of numbers for error enums. TODO: File bug.
        
        // Selection info
        cursorInfo.data = "";
        var sel = player.getSelection();
        if (sel != null) {
          var sx = Infinity;
          var sy = -Infinity;
          var cube = sel.cube;
          for (var dx = 0; dx <= 1; dx++)
          for (var dy = 0; dy <= 1; dy++)
          for (var dz = 0; dz <= 1; dz++) {
            var vec = [cube[0]+dx,cube[1]+dy,cube[2]+dz,1];
            renderer.transformPoint(vec);
            sx = Math.min(sx, vec[0]/vec[3]);
            sy = Math.max(sy, vec[1]/vec[3]);
          }
          if (isFinite(sx) && isFinite(sy)) {
            cursorInfoElem.style.left = (sx + 1) / 2 * theCanvas.width + "px";
            cursorInfoElem.style.bottom = (sy + 1) / 2 * theCanvas.height + "px";
            
            var world = player.getWorld();
            var value = world.g(cube[0],cube[1],cube[2]);
            var sub = world.gSub(cube[0],cube[1],cube[2]);
            var type = world.gt(cube[0],cube[1],cube[2]);
            var text = 
              value
              + (sub ? ":" + sub : "")
              + " at " + sel.cube;

            var circuit = world.getCircuit(cube);
            if (circuit !== null) {
              text += "\nCircuit: " + type.behavior.name + " " + circuit.describeBlock(cube);
            }
            cursorInfo.data = text;
          }
        }
        
        // Per-frame debug/stats info
        var text = "";
        {
          var pp = player.render.getPosition();
          var d = 2;
          text += "XYZ: " + pp[0].toFixed(d) + "," + pp[1].toFixed(d) + "," + pp[2].toFixed(d) + "\n";
        }
        if (errs.length) {
          lastGLErrors = errs;
          text += "GL errors:";
          errs.forEach(function (e) {
            text += " " + WebGLDebugUtils.glEnumToString(e);
          });
          text += "\n";
        } else if (lastGLErrors.length) {
          text += "Previous GL errors:";
          lastGLErrors.forEach(function (e) {
            text += " " + WebGLDebugUtils.glEnumToString(e);
          });
          text += "\n";
        }
        text += renderer.verticesDrawn + " vertices\n";
        text += fpsDesc + "\n";
        sceneInfo.data = text;
        
        chunkProgressBar.setByTodoCount(wrend.chunkRendersToDo());
        audioProgressBar.setByTodoCount(BlockType.audioRendersToDo());
        
        renderer.verticesDrawn = 0;
        renderCount++;
    }
    
    var fpsDesc = "", stepCount = 0, renderCount = 0, chunkRenders = 0;
    
    var lastStepTime = null;
    function doOneStep() {
      player.stepYourselfAndWorld();
      input.step();
      stepCount++;
    }
    function doStep() {
      // perform limited catch-up
      var now = Date.now();
      if (lastStepTime === null)
        lastStepTime = now;
      if ((now - lastStepTime) > MAX_CATCHUP_MS)
        lastStepTime = now - MAX_CATCHUP_MS;
      
      while ((now - lastStepTime) > TIMESTEP_MS) {
        doOneStep();
        lastStepTime += TIMESTEP_MS;
      }
    }
    
    var animFrameWasRequested = false;
    function scheduleDraw() {
      if (!animFrameWasRequested && readyToDraw && !renderer.contextLost) {
        window.requestAnimFrame(function () {
          animFrameWasRequested = false;

          // done here because chunk updating should be deprioritized at the same time drawing would be
          chunkRenders += player.render.getWorldRenderer().updateSomeChunks();

          drawScene(player.render);

          if (config.debugForceRender.get()) scheduleDraw();
        }, theCanvas);
        animFrameWasRequested = true;
      }
    }
    config.debugForceRender.listen({changed: function () { scheduleDraw(); return true; }});

    // statistics are reset once per second
    setInterval(function () {
      fpsDesc = stepCount + " steps/s, " + renderCount + " frames/s, " + chunkRenders + " chunk rebuilds";
      stepCount = renderCount = chunkRenders = 0;
      
      // audio spatial test
      //var world = player.getWorld();
      //var b = [world.wx/2, world.wy/2+10, world.wz/2];
      //CubesAudio.play(b, world.blockSet.get(2));
      //player.render.getWorldRenderer().renderCreateBlock(b);
    }, 1000);
    
    // for making our loading more async
    var ABORT = {};
    function sequence(actions, catcher) {
      var t0 = undefined;
      function sub(i) {
        if (i >= actions.length) {
          return;
        } else {
          setTimeout(function () {
            var a = actions[i];
            if (typeof a == 'string') {
              var t1 = Date.now();
              sceneInfo.data += a + "\n";
              if (typeof console !== 'undefined')
                console.log(t0 ? "(+"+(t1-t0)+" ms)" : "        ", a);
              t0 = t1;
            } else {
              try {
                if (actions[i]() === ABORT) return;
              } catch (e) {
                catcher(e);
              }
            }
            sub(i+1);
          }, 1);
        }
      }
      sub(0);
    }
    
    function webGLStart() {
      sceneInfo = dynamicText(document.getElementById("scene-info-text"));
      cursorInfoElem = document.getElementById("cursor-info");
      cursorInfo = dynamicText(cursorInfoElem);
      chunkProgressBar = new ProgressBar(document.getElementById("chunks-progress-bar"));
      audioProgressBar = new ProgressBar(document.getElementById("audio-progress-bar"));

      sequence([
        function () {
          if (typeof testSettersWork === 'undefined' || !testSettersWork()) {
            document.getElementById("feature-error-notice").style.removeProperty("display");
            document.getElementById("feature-error-text").appendChild(document.createTextNode("ECMAScript 5 property accessors on frozen objects"));
          }
        },
        "Setting up WebGL...",
        function () {
          
          theCanvas = document.getElementById('view-canvas');
          renderer = new Renderer(theCanvas);
          if (!renderer.context) {
            document.getElementById("webgl-error-notice").style.removeProperty("display");
            return ABORT;
          }
          gl = renderer.context;
        },
        "Loading worlds...",
        function () {
          var hasLocalStorage = typeof localStorage !== 'undefined';
          document.getElementById('local-save-controls').style.display = hasLocalStorage ? 'block' : 'none';
          document.getElementById('local-save-warning').style.display = !hasLocalStorage ? 'block' : 'none';
          if (hasLocalStorage) {
            var worldData = localStorage.getItem("world");
            if (worldData !== null) {
              try {
                worldH = cyclicUnserialize(JSON.parse(worldData), World);
              } catch (e) {
                if (typeof console !== 'undefined')
                  console.error(e);
                alert("Failed to load saved world!");
              }
            }
          } else {
            console.warn("localStorage not available; world will not be saved.");
          }
          if (!worldH) {
            worldH = generateWorlds();
          }
        },
        "Painting blocks...", // this is what takes the time in world renderer construction
        function () {
          // done after some GL init because player creates world renderer object internally
          player = new Player(worldH);
        },
        "Finishing...",
        function () {
          input = new Input(theCanvas, player.input, document.getElementById("menu"));
          theCanvas.focus();
          readyToDraw = true;

          setInterval(doStep, TIMESTEP_MS);
        },
        "Ready!"
      ], function (exception) {
        sceneInfo.data += exception;
        document.getElementById("load-error-notice").style.removeProperty("display");
        document.getElementById("load-error-text").appendChild(document.createTextNode("" + exception));
        throw exception; // propagate to browser console
      });
    }

</script>


</head>


<body onload="webGLStart();">
    <div class="overlay-bounds">
      <canvas id="view-canvas" tabindex="0" class="viewport" width="640" height="480">
        <div class="error-notice">
          <p>Sorry, but the web browser you are using does not appear to support WebGL (or even Canvas).</p>
        </div>
      </canvas>
      <div id="scene-info-overlay" class="overlay">
        <pre id="scene-info-text">Not ready...</pre>
        <div class="progress-bar" id="chunks-progress-bar" style="width: 20em;"></div>
        <div class="progress-bar" id="audio-progress-bar" style="width: 20em;"></div>
      </div>
      <pre id="cursor-info" class="overlay"></pre>
      <div id="menu-container">
        <div id="menu">
          <!-- dynamic content -->
        </div>
      </div>
    </div>
    <div id="error-notices">
    <div id="load-error-notice" class="error-notice" style="display: none;">
      <p>Sorry, but there was an unexpected error while loading the game.</p>
      <p><pre id="load-error-text" style="white-space: pre-wrap;"></pre></p>
    </div>
    <div id="feature-error-notice" class="error-notice" style="display: none;">
      <p>Sorry, the browser you are using does not support some required features. These problems were detected:</p>
      <p><pre id="feature-error-text" style="white-space: pre-wrap;"></pre></p>
      <p>If you are looking for a compatible browser, I recommend Google Chrome.</p>
    </div>
    <div id="webgl-error-notice" class="error-notice" style="display: none;">
      <p>Sorry, the web browser you are using does not appear to support WebGL.</p>
    </div>
    </div>

    <div id="toggles">
      <button id="optionsbtn" onclick="this.style.display='none'; document.getElementById('options').style.display='block'; document.getElementById('view-canvas').focus();">Options</button>
      <button id="helpbtn" onclick="this.style.display='none'; document.getElementById('help').style.display='block'; document.getElementById('view-canvas').focus();">Help</button>
    </div>

    <div id="options" class="sidebar" onclick="if (event.target.tagName == 'INPUT' || event.target.tagName == 'LABEL' || event.target.tagName == 'BUTTON' || event.target.tagName == 'TEXTAREA') return true; this.style.display='none'; document.getElementById('optionsbtn').style.display='inline'; document.getElementById('view-canvas').focus();" style="display: none;">
      <p>Click to close.</p>

      <h2>Save/Load</h2>
      
      <form onsubmit="return false;" action=""  style="text-align: center">
        <p id="local-save-controls">
          <button onclick="
            localStorage.setItem('world', JSON.stringify(cyclicSerialize(worldH))); return false;
          ">Save</button>
          <button onclick="
            worldH = cyclicUnserialize(JSON.parse(localStorage.getItem('world')), World);
            player.setWorld(worldH);
            return false;
          ">Revert to saved</button>
        </p>
        <p id="local-save-warning" style="display: none">
          Your browser does not appear to support local storage. This world will be lost when you close the page.
        </p>
        <p style="">
          <textarea id="loadfield" width="20" height="3" style="width: 80%;"></textarea>
          <br>
          <button onclick="
            document.getElementById('loadfield').value = JSON.stringify(cyclicSerialize(worldH)); return false;
          ">Text Export</button>
          <button onclick="
            while (document.getElementById('load-error').firstChild)
              document.getElementById('load-error').removeChild(
                document.getElementById('load-error').firstChild);
            try {
              worldH = cyclicUnserialize(JSON.parse(document.getElementById('loadfield').value), World)
              player.setWorld(worldH);
            } catch (e) {
              console.log(e);
              document.getElementById('load-error').appendChild(document.createTextNode(e));
            }
            return false;
          ">Text Import</button>
          <br>
          <div id="load-error" style="text-shadow: 0 0 .3em red;"></div>
        </p>
      </form>
      
      <h2>World</h2>

      <form onsubmit="return false;" action="">
        <table class="optionline">
          <tr><td>Shape: 
          <td><select id="generate_shape">
            <option value="fill">Flat-sided</option>
            <option value="island">Island</option>
          </select>
          <tr><td>Bumpiness:<td><input type="range" step="any" min="0" max="2" value="1" maxlength="4" size="4" id="generate_slope">
        </table>
        <script>config.generate_shape.bindControl("generate_shape");</script>
        <script>config.generate_slope.bindControl("generate_slope");</script>
        <table class="optionline" style="text-align: center;">
          <tr><td>Size: 
          <td><input type="number" min="1" max="9999" value="400" maxlength="4" size="4" id="generate_wx">
          <td><input type="number" min="1" max="512" value="128" maxlength="3" size="3" id="generate_wy">
          <td><input type="number" min="1" max="9999" value="400" maxlength="4" size="4" id="generate_wz">
          <tr><th><th>W<th>H<th>L
        </table>
        <script>config.generate_wx.bindControl("generate_wx");</script>
        <script>config.generate_wy.bindControl("generate_wy");</script>
        <script>config.generate_wz.bindControl("generate_wz");</script>
        <div style="text-align: center;">
          <button onclick="
            worldH = generateWorlds();
            player.setWorld(worldH);
            return false;
          ">Generate new world</button>
        </div>
      </form>

      <h2>Options</h2>

      <form onsubmit="return false;" action="">
        <div class="optionline">Field of view: <input type="range" step="any" min="45" max="140" value="60" maxlength="4" size="4" id="fov"></div>
        <script>config.fov.bindControl("fov");</script>
        <div class="optionline">Draw distance: <input type="range" step="any" min="10" max="500" value="100" maxlength="4" size="4" id="renderDistance"></div>
        <script>config.renderDistance.bindControl("renderDistance");</script>
        <div class="optionline"><label><input type="checkbox" id="lighting"> Lighting</label></div>
        <script>config.lighting.bindControl("lighting");</script>
        <div class="optionline"><label><input type="checkbox" id="bumpMapping"> Bump mapping</label></div>
        <script>config.bumpMapping.bindControl("bumpMapping");</script>
        <div class="optionline"><label><input type="checkbox" id="enableSound"> Sound</label></div>
        <script>
          document.getElementById("enableSound").disabled = !CubesAudio.audioSupported;
          config.sound.bindControl("enableSound");
        </script>
        
        <h3>Debug</h3>
        
        <div class="optionline"><label><input type="checkbox" id="debugForceRender"> Always render frames</label></div>
        <script>config.debugForceRender.bindControl("debugForceRender");</script>
        <div class="optionline"><label><input type="checkbox" id="debugTextureAllocation"> Show block texture</label></div>
        <script>config.debugTextureAllocation.bindControl("debugTextureAllocation");</script>
        <div class="optionline"><label><input type="checkbox" id="debugPlayerCollision"> Show character volume</label></div>
        <script>config.debugPlayerCollision.bindControl("debugPlayerCollision");</script>

        <p><button onclick="resetAllOptions(); return false;">Reset to defaults</button></p>
      </form>
    </div>

    <div id="help" class="sidebar" onclick="this.style.display='none'; document.getElementById('helpbtn').style.display='inline'; document.getElementById('view-canvas').focus();" style="display: none;">
      <h2>Help</h2>
      
      <p>Click to close this help.</p>
      
      <h3>Controls</h3>
      
      <table class="fancy">
        <tr><th colspan=2>Movement
        <tr><td><kbd>W</kbd> <kbd>A</kbd> <kbd>S</kbd> <kbd>D</kbd><br> or arrows<td>move horizontally
        <tr><td><kbd>Space</kbd><td>jump
        <tr><td><kbd>E</kbd><td>fly, move up
        <tr><td><kbd>C</kbd><td>land, move down
        <tr><td><kbd>Q</kbd><td>toggle mouselook
        <tr><th colspan=2>Blocks
        <tr><td>Left button<td> remove block
        <tr><td>Right button<td> place block
        <tr><td><kbd>Q</kbd><td> toggle block menu
        <tr><td><kbd>1</kbd>–<kbd>9</kbd>, <kbd>0</kbd><td>choose from menu
        <tr><td><kbd>R</kbd><td> edit targeted block
        <tr><td>Right button in menu<td> edit clicked block
        <tr><td><kbd>Esc</kbd>, <kbd>F</kbd><td> exit editing
      </table>

      <p>While you can edit any block to any shape, note that making the first block type (which makes up the underground volume in the default world) a non-cubical shape will likely be fatal to your frame rate.</p>

      <h3>Compatibility &amp; Bugs</h3>
      
      <p>Player movement does not work on Safari 5.1.</p>

    </div>
</body>

</html>
