<!--
   Except as noted,
   Copyright 2011 Kevin Reid, under the terms of the MIT License as detailed in
   the accompanying file README.md or <http://opensource.org/licenses/MIT>.
  
   Exception: The overall structure of WebGL initialization and context
   management is copied from Learning WebGL, Lesson 16, at
   http://learningwebgl.com/blog/?p=1786 (as of September 2011). No license is
   stated on that site, but I (Kevin Reid) believe that it is obviously the
   authors' intent to make this code free to use.
-->
<!doctype html>
<html><head>
<title>Cube Game</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="viewport" content="width=device-width">

<style type="text/css" media="screen">
  /* ensure that our viewport canvas fills the window */
  html, body, .viewport { margin: 0; border: 0; width: 100%; height: 100%; }
  
  html {
    background: gray; /* ordinarily invisible, but makes initial loading better */
  }
  
  .viewport {
    display: block; /* avoid invoking CSS line layout. */
    cursor: crosshair;
  }
  
  .overlay-bounds {
    display: block;
    position: relative;
    overflow: hidden;
    width: 100%;
    height: 100%;
  }
  
  #info {
    left: 1px;
    top: 1px;
  }
  .text-overlay {
    position: absolute;
    font-family: monospace;
    color: white;
    text-shadow: 0 0 .3em #000;
    margin: 0 0;
    display: table;
  }
  
  #menu {
    position: absolute;
    left: auto;
    right: auto;
    bottom: 2px;
    background: gray;
    background: rgba(0, 0, 0, 0.5);
    border-radius: 5px;
    display: block;
    text-align: center;
  }
  #menu canvas {
    margin: 1px 1px;
  }
  #menu .selectedTool {
    border-radius: 5px;
    margin: -1px -1px; /* outlines don't have radius */
    border: 2px solid white;
    background: gray;
  }
  
  .error-notice {
    position: absolute;
    top: 5em;
    right: 50%;
    margin-right: -17em;
    
    z-index: 1;
    border-radius: 2em;
    text-align: center;
    max-width: 30em;
    padding: 1em 2em;
    border: .2em solid red;
    
    background: white;
    color: black;
    font-family: 'Lucida Grande', sans-serif;
  }
  
  #toggles {
    position: absolute;
    top: 6px;
    right: 6px;
    text-align: right;
  }
  .sidebar {
    position: absolute;
    top: 0px;
    right: 0px;
    width: 16em;
    max-height: 100%;
    overflow: auto;
    color: white;
    background: black;
    background: rgba(80,80,80,0.7);
    padding: 0 0.8em;
  }
</style>

<script type="text/javascript" src="webgl-debug.js"></script>
<script type="text/javascript" src="webgl-utils.js"></script>
<script type="text/javascript" src="glMatrix.js"></script>
<script type="text/javascript" src="util.js"></script>
<script type="text/javascript" src="blockset.js"></script>
<script type="text/javascript" src="world.js"></script>
<script type="text/javascript" src="world-gen.js"></script>
<script type="text/javascript" src="world-render.js"></script>
<script type="text/javascript" src="block-render.js"></script>
<script type="text/javascript" src="player.js"></script>
<script type="text/javascript" src="input.js"></script>

<script id="shader-fs" type="x-shader/x-fragment">
    #ifdef GL_ES
    precision highp float;
    #endif
    
    varying vec4 vColor;
    varying vec3 vGridPosition;
    varying vec3 vFixedOrientationPosition;
    varying vec2 vTextureCoord;
    varying float vFog;
    varying vec3 vNormal;
    varying float vDistanceFromEye;

    uniform mat4 uPMatrix;
    uniform mat4 uMVMatrix;
    uniform bool uTextureEnabled;
    uniform sampler2D uSampler;
    uniform bool uLighting;
    uniform bool uBumpMapping;
    
    const vec4 cSky = vec4(0.1,0.3,0.5,1.0);   
    const vec4 cHorizon = vec4(0.7,0.8,1.0,1.0);  
    const vec4 cGround = vec4(0.5,0.4,0.4,1.0);
    const float cTileSize = 16.0; // TODO: duplicate hardcoded value
    const float cModEpsilon = 1e-20;
    const float cTileCurvature = 0.2;
    const float cTileBumpDistance = 7.0;

    const float cLightAmbient = 0.5;
    const vec3 cLight1Dir = vec3(0.8,-0.2,0);
    const vec3 cLight2Dir = vec3(-0.8,0.7,0.5);

    // What is the illumination from the given (unit vector) direction?
    float lightEnv(vec3 dir) {
      return max(0.0, dot(cLight1Dir, dir)) + max(0.0, dot(cLight2Dir, dir));
    }
    
    // Componentwise x^7. pow() is unsuitable for negative arguments.
    vec3 pow7vec3(vec3 x) {
      vec3 y = x*x*x;
      return y*y*x;
    }

    // Add amount of any component over 1.0 to all components (makes overbright colors turn to white)
    vec3 spill(vec3 v) {
      return v + vec3(max(1.0, max(v.r, max(v.g, v.b))) - 1.0);
    }

    float lighting() {
      // 'cell' is a vector with components in [-1.0, 1.0] indicating this point's
      // offset from the center of its sub-cube
      vec3 normal;
      if (uBumpMapping) {
        vec3 cell = (mod(vGridPosition * cTileSize + cModEpsilon, 1.0) - vec3(0.5)) * 2.0;
        normal = normalize(vNormal + cTileCurvature / max(1.0, vDistanceFromEye / cTileBumpDistance) * pow7vec3(cell));
      } else {
        normal = vNormal;
      }
      return cLightAmbient + lightEnv(normal);
    }
    
    void main(void) {
        vec4 color;

        // color/lighting calculation
        // if the vertex normal is zero, then that means "do not use lighting"
        color = vec4(vec3(vColor) * 
            (!uLighting || vNormal == vec3(0,0,0)
              ? 1.0 
              : lighting()), vColor.a);

        if (uTextureEnabled) {
          color = color * texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));

          // alpha test
          if (color.a <= 0.0)
            discard;
        }
        
        color = vec4(spill(vec3(color)), color.a);

        float elevationSine = vFixedOrientationPosition.y / length(vFixedOrientationPosition);
        vec4 fogColor = elevationSine < 0.0
          ? mix(cHorizon, cGround, clamp(log(1.0 + -elevationSine * 120.0), 0.0, 1.0))
          : mix(cHorizon, cSky, clamp(log(1.0 + elevationSine * 2.0), 0.0, 1.0));
        gl_FragColor = color * (1.0-vFog) + fogColor * vFog;
    }
</script>

<script id="shader-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec4 aVertexColor;
    attribute vec3 aVertexNormal;
    attribute vec2 aTextureCoord;

    uniform bool uTextureEnabled;
    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;
    uniform vec3 uViewPosition;
    uniform vec2 uPixelsPerClipUnit;
    uniform float uFogDistance;
    
    uniform bool uParticleMode;     // flag we're rendering point particles
    uniform float uParticleInterp;  // particle system evolution time, [0.0, 1.0]
    uniform bool uParticleExplode; // particles explode or appear/fade?
    
    varying vec4 vColor;
    varying vec3 vGridPosition;
    varying vec3 vFixedOrientationPosition;
    varying vec2 vTextureCoord;
    varying vec3 vNormal;
    varying float vFog;
    varying float vDistanceFromEye;
    
    void main(void) {
        vec3 vertexPosition;
        float pointScale;
        
        if (uParticleMode) {
          // center of block
          vec3 blockPart = floor(aVertexPosition) + 0.5;
          // offset from center of block
          vec3 particlePart = mod(aVertexPosition, 1.0) - 0.5;
          
          // pseudorandom vector constant for the point
          vec3 scramble = normalize(vec3(
            sin(dot(aVertexPosition, vec3(24121.9, 2398.1, 234.8))),
            sin(dot(aVertexPosition, vec3(1024.0, 28.0, 1834.0))),
            sin(dot(aVertexPosition, vec3(486.0, 282.4, 7.215)))
          ));
          
          vertexPosition = uParticleExplode
            ? aVertexPosition + (1.0 * scramble + 0.5 * particlePart) * pow(uParticleInterp, 3.0)
            : aVertexPosition + particlePart * (0.1 + uParticleInterp * 0.1);
          pointScale = 1.0 - pow(uParticleInterp * 1.0, 2.0);
        } else {
          vertexPosition = aVertexPosition;
        }
        
        vGridPosition = vertexPosition;
        vFixedOrientationPosition = vertexPosition - uViewPosition;
        vec4 relativePosition = uMVMatrix * vec4(vertexPosition, 1.0);
        gl_Position = uPMatrix * relativePosition;
        
        if (uParticleMode) {
          // Compute particle size
          vec4 testPosition = relativePosition;
          testPosition.x = uPixelsPerClipUnit.x / 16.0/* TODO: should be TILE_SIZE */ * 1.2/*appearance fudge factor*/;
          testPosition.y = 0.0;
          testPosition = uPMatrix * testPosition;
          gl_PointSize = testPosition.x / testPosition.w * pointScale;
        }
        
        vTextureCoord = aTextureCoord;
        
        // linear distance from eye, scaled to 1.0 = 100% fog
        vDistanceFromEye = length(vec3(relativePosition));
        
        // fog color mixing parameter
        vFog = clamp(pow(vDistanceFromEye/uFogDistance, 4.0), 0.0, 1.0);
        
        vColor = uTextureEnabled ? vec4(1.0) : aVertexColor;
        vNormal = aVertexNormal;
    }
</script>


<script type="text/javascript">
    "use strict";
    
    var DEBUG = false;
    var TIMESTEP = 1/30;
    
    // Settable using the options sidebar
    var configRenderDistance = 100;
    var configLighting = true;
    var configBumpMapping = true;
    var configDebugTextureAllocation = false;

    // GL objects
    var gl;
    var theCanvas;
    
    var sceneInfo;
    var cursorInfoElem;
    var cursorInfo;
    
    // Game state, etc. objects
    var player;
    var worldH;
    var input;
    
    function initGL(canvas) {
        gl = canvas.getContext("experimental-webgl", {
          antialias: false // MORE FILLRATE!!!
        });
        if (DEBUG) {
          gl = WebGLDebugUtils.makeDebugContext(gl);
        } else {
          WebGLDebugUtils.init(gl);
        }
        if (!gl) {
            if (typeof console !== 'undefined') console.log("failed to get context: ", gl);
        }
    }
    
    // prepareProgram fills in these with the locations of the shader program variables
    var attribs = {};
    var uniforms = {};

    // Projection trans

    // View and projection transformation globals.
    var pMatrix = mat4.create();
    var mvMatrix = mat4.create();
    var viewPosition = vec3.create();

    function sendViewUniforms() {
        gl.uniformMatrix4fv(uniforms.uMVMatrix, false, mvMatrix);
        gl.uniform3fv(uniforms.uViewPosition, viewPosition);
    }

    function updateViewport() {
      var pagePixelWidth = parseInt(window.getComputedStyle(theCanvas,null).width);
      var pagePixelHeight = parseInt(window.getComputedStyle(theCanvas,null).height);
      
      // Specify canvas resolution
      theCanvas.width = pagePixelWidth;
      theCanvas.height = pagePixelHeight;
      
      // WebGL is not guaranteed to give us that resolution; instead, what it
      // can supply is returned in .drawingBuffer{Width,Height}. However, those
      // properties are not supported by, at least, Firefox 6.0.2.
      if (!("drawingBufferWidth" in gl)) {
        gl.drawingBufferWidth = pagePixelWidth;
        gl.drawingBufferHeight = pagePixelHeight;
      }
      
      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
      gl.uniform2f(uniforms.uPixelsPerClipUnit, gl.drawingBufferWidth / 2,
                                                gl.drawingBufferHeight / 2);

      updateProjection();
    }
    
    function updateProjection() {
      mat4.perspective(90, // vertical FOV
                       gl.drawingBufferWidth / gl.drawingBufferHeight, // aspect ratio
                       0.1, // near clip
                       configRenderDistance, // far clip
                       pMatrix);
      
      gl.uniformMatrix4fv(uniforms.uPMatrix, false, pMatrix);
      
      // uFogDistance is handled by drawScene.
    }
    
    function changedRenderDistance() {
      updateProjection();
      player.render.getWorldRenderer().changedRenderDistance();
    }
    
    function changedRenderOptions() {
      gl.uniform1i(uniforms.uLighting, configLighting ? 1 : 0);
      gl.uniform1i(uniforms.uBumpMapping, configBumpMapping ? 1 : 0);
    }
    
    // Returns a pair of points along the line of aim of the screen cursor.
    function getAimRay() {
      var pos = input.getMousePos();
      var glxy = [pos[0] / theCanvas.width * 2 - 1, -(pos[1] / theCanvas.height * 2 - 1)];
      
      var unproject = mat4.identity(mat4.create());
      player.render.applyViewRot(unproject);
      player.render.applyViewTranslation(unproject);
      mat4.multiply(pMatrix, unproject, unproject);
      mat4.inverse(unproject);

      var pt1 = fixedmultiplyVec3(unproject, vec3.create([glxy[0], glxy[1], 0]));
      var pt2 = fixedmultiplyVec3(unproject, vec3.create([glxy[0], glxy[1], 1]));

      return [pt1, pt2];
    }

    function raycastFromScreen(radius, callback) {
      var pts = getAimRay();
      return player.getWorld().raycast(pts[0], pts[1], radius, callback);
    }
    
    function RenderBundle(primitive, optTexture, calcFunc, options) {
      options = options || {};
      
      var vbuf = gl.createBuffer();
      var nbuf = gl.createBuffer();
      if (!optTexture) var cbuf = gl.createBuffer();
      if (optTexture) var tbuf = gl.createBuffer();
      var numVertices;
      
      this.recompute = function () {
        var vertices = [];
        var normals = [];
        var colors = optTexture ? null : [];
        var texcoords = optTexture ? [] : null;
        calcFunc(vertices, normals, optTexture ? texcoords : colors);
        numVertices = Math.floor(vertices.length / 3);

        if (vertices.length !== normals.length) {
          throw new Error("wrong number of normals");
        }

        gl.bindBuffer(gl.ARRAY_BUFFER, vbuf);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, nbuf);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);

        if (optTexture) {
          if (texcoords.length !== numVertices * 2) {
            throw new Error("wrong number of texture coordinates");
          }
          gl.bindBuffer(gl.ARRAY_BUFFER, tbuf);
          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texcoords), gl.STATIC_DRAW);
        } else {
          if (colors.length !== numVertices * 4) {
            throw new Error("wrong number of colors");
          }
          gl.bindBuffer(gl.ARRAY_BUFFER, cbuf);
          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
        }
      };
      
      function draw() {
        gl.bindBuffer(gl.ARRAY_BUFFER, vbuf);
        gl.vertexAttribPointer(attribs.aVertexPosition, 3, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, nbuf);
        gl.vertexAttribPointer(attribs.aVertexNormal, 3, gl.FLOAT, false, 0, 0);
        
        gl.uniform1i(uniforms.uTextureEnabled, optTexture ? 1 : 0);

        if (optTexture) {
          gl.enableVertexAttribArray(attribs.aTextureCoord);
          gl.disableVertexAttribArray(attribs.aVertexColor);
          
          gl.bindBuffer(gl.ARRAY_BUFFER, tbuf);
          gl.vertexAttribPointer(attribs.aTextureCoord, 2, gl.FLOAT, false, 0, 0);
  
          gl.activeTexture(gl.TEXTURE0);
          gl.bindTexture(gl.TEXTURE_2D, optTexture);
          gl.uniform1i(uniforms.uSampler, 0);
        } else {
          gl.disableVertexAttribArray(attribs.aTextureCoord);
          gl.enableVertexAttribArray(attribs.aVertexColor);

          gl.bindBuffer(gl.ARRAY_BUFFER, cbuf);
          gl.vertexAttribPointer(attribs.aVertexColor, 4, gl.FLOAT, false, 0, 0);
        }
        sendViewUniforms();
        totalVertices += numVertices;
        gl.drawArrays(primitive, 0, numVertices);
      };
      this.draw = options.aroundDraw ? function () { options.aroundDraw(draw); } : draw;
      
      this.deleteResources = function () {
        gl.deleteBuffer(vbuf);
        gl.deleteBuffer(nbuf);
        if (cbuf) gl.deleteBuffer(cbuf);
        if (tbuf) gl.deleteBuffer(tbuf);
        vbuf = nbuf = cbuf = tbuf = numVertices = null;
      }
      
      this.recompute();
    }
    
    // TODO: the interface for this is lousy. blockWorld==null means we're creating a block, nonnull destroying
    function BlockParticles(world, location, blockWorld, symm) {
      var k = 2;
      var t0 = Date.now();
      var rb = new RenderBundle(gl.POINTS, null, function (vertices, normals, colors) {
        var TILE_SIZE = World.TILE_SIZE;
        for (var x = 0; x < TILE_SIZE; x++) {
          for (var y = 0; y < TILE_SIZE; y++) {
            for (var z = 0; z < TILE_SIZE; z++) {
              if (blockWorld == null) {
                if (!(x < k || x >= TILE_SIZE-k || y < k || y >= TILE_SIZE-k || z < k || z >= TILE_SIZE-k))
                  continue;
                var c = 1.0 - Math.random() * 0.04;
                colors.push(c,c,c,1);
              } else {
                blockWorld.gt(x,y,z).writeColor(1, colors, colors.length);
                if (colors[colors.length - 1] <= 0.0) {
                  // transparent, skip
                  colors.length -= 4;
                  continue;
                }
              }
              var v = applyCubeSymmetry(symm, 1, [
                (x+0.5)/TILE_SIZE,
                (y+0.5)/TILE_SIZE,
                (z+0.5)/TILE_SIZE
              ]);
              
              vertices.push(location[0]+v[0],
                            location[1]+v[1],
                            location[2]+v[2]);
              normals.push(0,0,0); // disable lighting
            }
          }
        }
      }, {
        aroundDraw: function (draw) {
          gl.uniform1i(uniforms.uParticleMode, 1);
          gl.uniform1i(uniforms.uParticleExplode, blockWorld ? 1 : 0);
          gl.uniform1f(uniforms.uParticleInterp, t());
          draw();
          gl.uniform1i(uniforms.uParticleMode, 0);
        }
      });
      
      function t() {
        return Math.min((Date.now() - t0) * 0.003, 1);
      }
      
      rb.expired = function () { return t() >= 1; };
      
      return rb;
    }

    var debugR;
    var skyboxR;
    
    function initBuffers() {
      debugR = new RenderBundle(gl.LINES, null, function (vertices, normals, colors) {
        if (player) player.renderDebug(vertices, normals, colors);
      });
      
      skyboxR = new RenderBundle(gl.TRIANGLES, null, function (vertices, normals, colors) {
        // abstracted in case this is useful elsewhere ...
        function cube(vertices, colors, size, outward) {
          function ppush(a, b, c) {
            var v = [];
            v[dim] = a;
            v[da] = b;
            v[db] = c;
            vertices.push(v[0], v[1], v[2]);
            normals.push(0,0,0); // TODO stub
            colors.push(1, 0, 0, 1);
          }
          for (var dim = 0; dim < 3; dim++) {
            for (var dir = -1; dir < 2; dir+=2) {
              var da = mod(dim + (outward ? 1 : -1) * dir, 3);
              var db = mod(dim + (outward ? 2 : -2) * dir, 3);
              ppush(dir*size, -size, -size);
              ppush(dir*size,  size, -size);
              ppush(dir*size,  size,  size);
              ppush(dir*size,  size,  size);
              ppush(dir*size, -size,  size);
              ppush(dir*size, -size, -size);
            }
          }
        }
        
        // While rendering this, the fog distance is adjusted so that anything
        // farther than 1 unit is fully fogged.
        cube(vertices, colors, 10, false);
      });
    }
    
    var lastGLErrors = [];
    function drawScene(playerRender) {
        var wrend = playerRender.getWorldRenderer();

        // Rendering settings for skybox
        mat4.identity(mvMatrix);
        playerRender.applyViewRot(mvMatrix);
        viewPosition = [0,0,0];
        gl.uniform1f(uniforms.uFogDistance, 1); // 0 would be div-by-0
        gl.disable(gl.DEPTH_TEST);
        
        // The skybox exceeeds the fog distance, so it is rendered fully fogged
        // and only the fog-shading determines the sky color. This ensures that
        // normal geometry fades smoothly into the sky rather than turning
        // a possibly-different fog color.
        skyboxR.draw();
        
        // Rendering settings for normal geometry
        gl.enable(gl.DEPTH_TEST);
        gl.clear(gl.DEPTH_BUFFER_BIT); // Backdrop depth is irrelevant
        gl.uniform1f(uniforms.uFogDistance, configRenderDistance);

        viewPosition = playerRender.getPosition();
        playerRender.applyViewTranslation(mvMatrix);

        wrend.draw();
        debugR.draw();
        player.render.selectionRender.draw();
        
        var e, errs = [];
        while (e = gl.getError()) {
          errs.push(e);
        }
        
        // Selection info
        cursorInfo.data = "";
        var sel = player.getSelection();
        if (sel != null) {
          var sx = Infinity;
          var sy = -Infinity;
          var cube = sel.cube;
          for (var dx = 0; dx <= 1; dx++)
          for (var dy = 0; dy <= 1; dy++)
          for (var dz = 0; dz <= 1; dz++) {
            var vec = [cube[0]+dx,cube[1]+dy,cube[2]+dz,1];
            mat4.multiplyVec4(mvMatrix, vec);
            mat4.multiplyVec4(pMatrix, vec);
            sx = Math.min(sx, vec[0]/vec[3]);
            sy = Math.max(sy, vec[1]/vec[3]);
          }
          if (isFinite(sx) && isFinite(sy)) {
            cursorInfoElem.style.left = (sx + 1) / 2 * theCanvas.width + "px";
            cursorInfoElem.style.bottom = (sy + 1) / 2 * theCanvas.height + "px";
            var world = player.getWorld();
            var sub = world.gSub(cube[0],cube[1],cube[2]);
            cursorInfo.data = 
              world.g(cube[0],cube[1],cube[2])
              + (sub ? ":" + sub : "")
              + " at " + sel.cube;
          }
        }
        
        // Per-frame debug/stats info
        var text = "";
        {
          var pp = viewPosition;
          var d = 2;
          text += "XYZ: " + pp[0].toFixed(d) + "," + pp[1].toFixed(d) + "," + pp[2].toFixed(d) + "\n";
        }
        if (errs.length) {
          lastGLErrors = errs;
          text += "GL errors:";
          errs.forEach(function (e) {
            text += " " + WebGLDebugUtils.glEnumToString(e);
          });
          text += "\n";
        } else if (lastGLErrors.length) {
          text += "Previous GL errors:";
          lastGLErrors.forEach(function (e) {
            text += " " + WebGLDebugUtils.glEnumToString(e);
          });
          text += "\n";
        }
        text += totalVertices + " vertices\n";
        text += fpsDesc + "\n";
        text += wrend.debugText();
        sceneInfo.data = text;
        
        totalVertices = 0;
        renderCount++;
    }
    
    var fpsDesc = "", stepCount = 0, renderCount = 0, chunkRenders = 0, totalVertices = 0;
    
    function doStep() {
      player.stepYourselfAndWorld();
      input.step();
      stepCount++;
    }
    
    var animFrameWasRequested = false;
    function scheduleDraw() {
      if (!animFrameWasRequested) {
        window.requestAnimFrame(function () {
          animFrameWasRequested = false;

          // done here because chunk updating should be deprioritized at the same time drawing would be
          chunkRenders += player.render.getWorldRenderer().updateSomeChunks();

          drawScene(player.render);
        }, theCanvas);
        animFrameWasRequested = true;
      }
    }

    // statistics are reset once per second
    setInterval(function () {
      fpsDesc = stepCount + " steps/s, " + renderCount + " frames/s, " + chunkRenders + " chunk rebuilds";
      stepCount = renderCount = chunkRenders = 0;
    }, 1000);
    
    // for making our loading more async
    var ABORT = {};
    function sequence(actions, catcher) {
      var t0 = undefined;
      function sub(i) {
        if (i >= actions.length) {
          return;
        } else {
          setTimeout(function () {
            var a = actions[i];
            if (typeof a == 'string') {
              var t1 = Date.now();
              sceneInfo.data += a + "\n";
              if (typeof console !== 'undefined')
                console.log(t0 ? "(+"+(t1-t0)+" ms)" : "        ", a);
              t0 = t1;
            } else {
              try {
                if (actions[i]() === ABORT) return;
              } catch (e) {
                catcher(e);
              }
            }
            sub(i+1);
          }, 1);
        }
      }
      sub(0);
    }
    
    function webGLStart() {
      sceneInfo = dynamicText(document.getElementById('info'));
      cursorInfoElem = document.getElementById('cursor-info');
      cursorInfo = dynamicText(cursorInfoElem);

      sequence([
        "Getting WebGL...",
        function () {
          theCanvas = document.getElementById('view-canvas');
          initGL(theCanvas);
          if (!gl) {
            document.getElementById("webgl-error-notice").style.removeProperty("display");
            return ABORT;
          }
        },
        "Setting up WebGL...",
        function () {
          prepareProgram(gl,
                         prepareShader(gl, "shader-vs"),
                         prepareShader(gl, "shader-fs"),
                         attribs, uniforms);          
          
          // Set up viewport and projection matters
          updateViewport();
          window.addEventListener("resize", function () {
            updateViewport();
            return true;
          }, false);
          
          // Send rendering options
          changedRenderOptions();

          // Initial GL state
          gl.enableVertexAttribArray(attribs.aVertexPosition);
          gl.enableVertexAttribArray(attribs.aVertexNormal);
          gl.enable(gl.DEPTH_TEST);
          gl.enable(gl.CULL_FACE);
          
          initBuffers();
        },
        "Loading worlds...",
        function () {
          var hasLocalStorage = typeof localStorage !== 'undefined';
          document.getElementById('local-save-controls').style.display = hasLocalStorage ? 'block' : 'none';
          document.getElementById('local-save-warning').style.display = !hasLocalStorage ? 'block' : 'none';
          if (hasLocalStorage) {
            var worldData = localStorage.getItem("world");
            if (worldData !== null) {
              try {
                worldH = World.unserialize(JSON.parse(worldData));
              } catch (e) {
                if (typeof console !== 'undefined')
                  console.error(e);
                alert("Failed to load saved world!");
              }
            }
          } else {
            console.warn("localStorage not available; world will not be saved.");
          }
          if (!worldH) {
            worldH = generateWorlds();
          }
        },
        "Painting blocks...", // this is what takes the time in world renderer construction
        function () {
          // done after some GL init because player creates world renderer object internally
          player = new Player(worldH);
        },
        "Finishing...",
        function () {
          input = new Input(theCanvas, player.input, document.getElementById("menu"));
          theCanvas.focus();

          // TODO: use webgl utils to avoid wasting time rendering frames if invisible
          setInterval(doStep, 1000*TIMESTEP);
        },
        "Ready!"
      ], function (exception) {
        sceneInfo.data += exception;
        document.getElementById("load-error-notice").style.removeProperty("display");
        document.getElementById("load-error-text").appendChild(document.createTextNode("" + exception));
        throw exception; // propagate to browser console
      });
    }

</script>


</head>


<body onload="webGLStart();">
    <div class="overlay-bounds">
      <canvas id="view-canvas" tabindex="0" class="viewport" width="640" height="480">
        <div class="error-notice">
          <p>Sorry, but the web browser you are using does not appear to support WebGL (or even Canvas).</p>
        </div>
      </canvas>
      <pre id="info" class="text-overlay">Not ready...</pre>
      <pre id="cursor-info" class="text-overlay"></pre>
      <div id="menu">
        <!-- arbitrary initial position -->
      </div>
    </div>
    <div id="webgl-error-notice" class="error-notice" style="display: none;">
      <p>Sorry, the web browser you are using does not appear to support WebGL.</p>
    </div>
    <div id="load-error-notice" class="error-notice" style="display: none;">
      <p>Sorry, but there was an unexpected error while loading the game.</p>
      <p><pre id="load-error-text" style="white-space: pre-wrap;"></pre></p>
    </div>

    <div id="toggles">
      <button id="optionsbtn" onclick="this.style.display='none'; document.getElementById('options').style.display='block'; document.getElementById('view-canvas').focus();">Options</button>
      <button id="helpbtn" onclick="this.style.display='none'; document.getElementById('help').style.display='block'; document.getElementById('view-canvas').focus();">Help</button>
    </div>

    <div id="options" class="sidebar" onclick="if (event.target.tagName == 'INPUT' || event.target.tagName == 'LABEL' || event.target.tagName == 'BUTTON' || event.target.tagName == 'TEXTAREA') return true; this.style.display='none'; document.getElementById('optionsbtn').style.display='inline'; document.getElementById('view-canvas').focus();" style="display: none;">
      <p>Click to close.</p>

      <h2>World</h2>
      
      <form onsubmit="return false;" action=""  style="text-align: center">
        <p id="local-save-controls">
          <button onclick="
            localStorage.setItem('world', JSON.stringify(worldH.serialize())); return false;
          ">Save</button>
          <button onclick="
            worldH = World.unserialize( JSON.parse( localStorage.getItem('world')));
            player.setWorld(worldH);
            return false;
          ">Revert to saved</button>
          <button onclick="
            worldH = generateWorlds();
            player.setWorld(worldH);
            return false;
          ">Start over</button>
        </p>
        <p id="local-save-warning" style="display: none">
          Your browser does not appear to support local storage. This world will be lost when you close the page.
        </p>
        <p style="">
          <textarea id="loadfield" width="20" height="3" style="width: 80%;"></textarea>
          <br>
          <button onclick="
            document.getElementById('loadfield').value = JSON.stringify(worldH.serialize()); return false;
          ">Text Export</button>
          <button onclick="
            while (document.getElementById('load-error').firstChild)
              document.getElementById('load-error').removeChild(
                document.getElementById('load-error').firstChild);
            try {
              worldH = World.unserialize( JSON.parse( document.getElementById('loadfield').value))
              player.setWorld(worldH);
            } catch (e) {
              console.log(e);
              document.getElementById('load-error').appendChild(document.createTextNode(e));
            }
            return false;
          ">Text Import</button>
          <br>
          <div id="load-error" style="text-shadow: 0 0 .3em red;"></div>
        </p>
      </form>
      
      <h2>Options</h2>

      <form onsubmit="return false;" action="">
        <div class="optionline">Render distance: <input type="range" min="10" max="500" value="100" maxlength="4" size="4" onchange="configRenderDistance = parseFloat(this.value); changedRenderDistance(); return true;" style="vertical-align: middle;"></div>
        <div class="optionline"><label><input type="checkbox" checked onchange="configLighting = this.checked; changedRenderOptions(); return true;"> Lighting</label></div>
        <div class="optionline"><label><input type="checkbox" checked onchange="configBumpMapping = this.checked; changedRenderOptions(); return true;"> Bump mapping</label></div>
        
        <h3>Debug</h3>
        
        <p><label><input type="checkbox" onchange="configDebugTextureAllocation = this.checked; return true;"> Display block texture</label></p>
      </form>
    </div>

    <div id="help" class="sidebar" onclick="this.style.display='none'; document.getElementById('helpbtn').style.display='inline'; document.getElementById('view-canvas').focus();" style="display: none;">
      <h2>Help</h2>
      
      <p>Click to close this help.</p>
      
      <h3>Controls</h3>
      
      <p>Standard W A S D keys or arrow keys to move horizontally. Turn by moving the cursor close to the edges of the window. (Sorry, can't capture the mouse in a web browser.) Spacebar to jump or E and C to move vertically (there is no separate flight mode).</p>
      
      <p>Blocks are selected using the mouse. The left button adds or removes blocks at the location of the white rectangle cursor; the right button brings up a menu for choosing block types (the empty square at the top left is the removal tool). The number keys can be used instead of the menu.</p>

      <p>The R key enters the world of the selected block; the F key exits out to the previous world. While you can edit any block to any shape, note that making the first block type, which makes up the underground volume, a non-cubical shape will likely be fatal to your frame rate. The terrain surface is also somewhat dangerous in this way.</p>

      <h3>Compatibility &amp; Bugs</h3>
      
      <p>Player movement does not work on Safari 5.1. Right mouse button does not work on Firefox 6.0.2.</p>
      
      <p>The physics is still glitchy, and you can get permanently stuck simply by placing a block where you are.</p>

    </div>
</body>

</html>
